<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-tsvwg-careful-resume-01"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
ipr values: full3667, noModification3667, noDerivatives3667
you can add the attributes updates="NNNN" and obsoletes="NNNN"
they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
full title is longer than 39 characters -->

    <title abbrev="Careful Congestion Control Convergence">Careful Convergence of Congestion 
    Control from Retained State</title>

    <author fullname="Nicolas Kuhn" initials="N" surname="Kuhn">
      <organization>Thales Alenia Space</organization>

      <address>
        <email>nicolas.kuhn.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Emile Stephan" initials="E" surname="Stephan">
      <organization>Orange</organization>

      <address>
        <email>emile.stephan@orange.com</email>
      </address>
    </author>

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>Department of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <code>AB24 3UE</code>

          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Christian Huitema" initials="C" surname="Huitema">
      <organization>Private Octopus Inc.</organization>

      <address>
        <email>huitema@huitema.net</email>
      </address>
    </author>

    <date year="2023" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
in the current day for you. If only the current year is specified, xml2rfc will fill
in the current day and month for you. If the year is not the current one, it is
necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
purpose of calculating the expiry date).  With drafts it is normally sufficient to
specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
IETF is fine for individual submissions.
If this element is not present, the default is "Network Working Group",
which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>congestion control, QUIC</keyword>

    <!-- Keywords will be incorporated into HTML output
files in a meta tag but they have no effect on text or nroff
output. If you submit your draft to the RFC Editor, the
keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies a cautious method for IETF transports that
      enables fast startup of congestion control for a wide
      range of connections or reconnections.</t>
      <t>The method reuses a set of computed congestion control parameters that
      are based on previously observed path characteristics between
      the same pair of transport endpoints. These parameters
      are stored, allowing them to be later used to modify the congestion control behavior
      of a subsequent connection. The document discusses assumptions
      and defines requirements around how a
      sender utilizes these parameters to provide opportunities for a
      connection to more quickly get up to speed (i.e. utilize the available
      capacity). It discusses how the method impacts the capacity at a
      shared network bottleneck and the safe response that is needed after any
      indication that the new rate is inappropriate.</t>
    </abstract>
  </front>

<middle>
    <section anchor="sec:introduction" title="Introduction">
        <t>All Internet transports are required to either use a Congestion Control (CC) method, or
        to constrain their rate of transmission <xref target="RFC8085"></xref>. In 2010,
        a survey of alternative CC methods <xref target="RFC5783"></xref>, noted that there
        are challenges when a CC method operates across an Internet path with a high and/or
	variable bandwidth-delay product (BDP). This mechanism targets a 
	solution for these challenges.</t>

        <t>A CC method typically takes time to ramp-up the packet rate,
        called the "slow-start phase", informally known as the time to "Get up
        to speed". This slow start phase defines a time in which a sender
        intentionally uses less capacity than might be available, with the
        intention to avoid or limit overshooting the available capacity at a bottleneck.
        The slow start design can increase queuing (latency/jitter) and/or
        congestion packet loss to the flow. Any overshoot in the capacity can have a
        detrimental effect on other flows sharing a common bottleneck. In the
        extreme case, persistent congestion could result in unwanted starvation of
        other flows <xref target="RFC8867"></xref> (i.e., Preventing other flows
        from successfully sharing a common bottleneck).</t>

        <t>The method is expected to reduce the time to complete a transfer
            when the transfer sends significantly more data than allowed by the
	    Initial congestion window (IW), and
            where the BDP is also significantly
            more than the product of the IW and the  Round Trip Rime (RTT).</t>
        <t>It introduces an alternative method to select initial CC parameters,
        that seek to more rapidly and safely grow the congestion
        window (cwnd).
        This method is based on temporal sharing (sometimes known as
        caching) of a saved set of CC parameters that relate to previous observations
	of the same path. The saved CC parameters include:
        the bottleneck
        bandwidth, available capacity, and RTT. These
        parameters are stored and used to modify the CC
        behavior of a subsequent connection between the same local and remote endpoints.</t>

        <t>When used with the QUIC transport, this provides transport services that resemble
        those currently available in TCP, using methods such as TCP Control Block (TCB) 
		<xref target="RFC9040"></xref> caching.</t>

        <section title="Using the Saved Set of CC Parameters with Care">
            <t>"Generally, implementations are advised
            to be cautious when using previous values on a new path", as stated in <xref
            target="RFC9000"></xref>. This advice is appropriate for any IETF transport protocol.
	    Care is therefore needed 
            to assure safe use and to be robust to changes
            in traffic patterns, network routing and link/node conditions.
            There are cases where using the saved parameters of a previous
            connection are not appropriate.</t>
        </section>  <!-- end of use with care -->
          
        <section title="Receiver Preference">
            <t>Whilst a sender could take optimization decisions without considering
            the receiver's preference, there are cases where a client at the receiver
            could have information that
            is not available at the sender, or might benefit from
	     understanding that careful resume can be used. In these cases, a client
            could explicitly ask for tuning the CC
             when an application continues transmission or to ask to inhibit this tuning.</t>
	    <t>An indication from the server that the method might be available, could
            allow a receiver to tune policies for using the connection and managing the receiver
            window or flow credit.</t>		
           <t> Examples where a receiver could request not to use the method when:
            <list style="numbers">
            <t>the receiver understands that there is a different pattern of traffic for a connection
            (e.g., insight into the volume of data to be sent, the length of the session, or the maximum transfer rate required);</t>
            <t>a receiver has a local indication that the path/local interface has changed since CC parameters were stored;</t>
            <t>there is information related to the current hardware limitations at the receiver;</t>
            <t> the receiver understands the capacity that will be needed for other concurrent flows
            that might be expected to share the capacity of the path.</t>

            </list></t>

            <t>QUIC introduces the concept of transport parameters (Section 4 of
                <xref target="RFC9000"></xref>). 
	     A related document proposes an exchange for QUIC that communicates 
            the sender-generated set of CC parameters to be stored at the receiver
            <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>.
            By transferring the information to a receiver, this also releases the
            sender from needing to retain transport state for each
            receiver. This document also evaluates the potential
            for malicious use.</t>
        </section> <!-- end of Receiver Preference -->

        <section anchor="sec-use_case" title="Examples of Scenarios of Interest">

            <t> This section provides a set of examples where the method is expected to improve performance.</t>

            <t>In one example, an application could use a series of connections over the
            same path (i.e., resume a connection to the same endpoint).
            Without this method,
            each connection would need to individually
            discover appropriate CC parameters.</t>

            <t>Either or both endpoints can assume the role of a
            sender or a receiver. The method supports a bidirectional data transfer,
            where both endpoints simultaneously send data to
            each other (e.g., remote execution of an application, or a
            bidirectional video conference call).</t>
	
                <t>Another example is when the application reconnects after a disruption that
                had temporarily reduced the path
                capacity (e.g., after a link propagation
                impairment, or  where a user on a train journey travels through
                different areas of connectivity) before the endpoint
                returns to use a path with the original characteristics.</t>

            <t>
		There is particular benefit when
		a path has an RTT much larger than for typical
                Internet paths, such as endpoints connected via a satellite access network.
		In a specific example, it could require 9 seconds to complete a 5.3 MB transfer
                using standard CC, whereas using the
                specified method the transfer time could reduce to 4 seconds <xref
                    target="IJSCN"></xref>. The time to complete a 1 MB transfer could
                be reduced by 62 % <xref target="MAPRG111"></xref>. Benefit is also
                expected for other sizes of transfer and for different path
                characteristics when the path has a large BDP.</t>

                <t>{XXX-Editor note: A future revision can provide further Path Examples here.}</t>
        </section> <!-- end of examples -->
   
    </section> <!-- end of introduction and motivation -->

<!-- ************************************ -->
<!-- The protocol spec follows below here -->

<section anchor="notation" title="Language, notations and terms">

      <t>This section provides a brief summary of key terms and the
      requirements language that is used.</t>

    <section anchor="sec:req_language" title="Requirements Language">
        <t>The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in BCP
        14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when,
        and only when, they appear in all capitals, as shown here.</t>
    </section>

    <section title="Use of saved CC parameters by a Sender">
        <t>CC parameters are used by this method for two functions:
        <list>
            <t>Information to characterize the saved path, to allow a sender to
            confirm whether the saved information indicates the current path
            is consistent with the CC parameters for a saved path.</t>
            <t>Information about the capacity that was available for a path,
            to allow a later sender to
            determine an appropriate set of CC parameters for re-using the path.</t>
        </list></t>
    </section> <!-- End of Notation: the information -->

    <section anchor="sec-terms_def" title="Notations and Terms">
        <t> The document uses language drawn
        from a range of IETF RFCs.  It defines current, and saved values for a set of CC
        parameters:
        <list style="symbols">

            <!-- GF (Feb 2023): Removed the IW from this information block??? -->
            <!-- it could potentially be in BDP but is not needed here -->
            <!--	<t>IW: Initial Window <xref target="RFC9002"></xref>;</t> -->
            <!--            <t>current_iw: Current IW;</t> -->
            <!--            <t>recom_iw: Recommended IW;</t> -->

            <t>current_bb : The currently estimated bottleneck bandwidth;</t>

            <t>saved_bb: The estimated bottleneck bandwidth preserved from a
            previous connection;</t>

            <t>current_rtt: The current RTT;</t>

            <t>saved_rtt: The measured RTT, preserved from a previous
            connection;</t>

            <t>endpoint_token: An Endpoint Token for a receiver;</t>

            <t>current_endpoint_token: The current Endpoint Token of the receiver;</t>

            <t>saved_endpoint_token: The Endpoint Token of a previous connection by the
            receiver;</t>
		
	     <t>jump_cwnd: The resumed cwnd, used in the Unvalidated Phase.</t>
        </list>
        </t>

        <t>The Endpoint Token is described in <xref target="endpoint_token"></xref>.
        </t>

        </section> <!-- End of Notation: end of terms -->
    </section><!-- End of Notation -->

    <section anchor="sec-phase" title="The Phases of CC using Careful Resume">
      <t>This section defines a series of phases that the
      CC algorithm moves through as a connection
      uses the Careful Resume method.</t> 
      
      <!-- GF: Uses subsections to match next section format -->
      
        <section title="Observe Phase">
              <t>During a previous connection, information about the specific path
          	to an endpoint is saved. This is used to characterize the path and
         	to indicate the capacity that was available. It includes the current RTT
              (current_rtt), bottleneck bandwidth (current_bb) and a current receiver
              Endpoint Token (current_endpoint_token) stored as the saved_rtt, saved_bb and
		      saved_endpoint_token <xref target="sec-measure"></xref>. An implementation
	      could store the information at the server (or could exchange this information
		with a receiver, as detailed in <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>).</t>
         </section> <!-- title="Observe Phase:"-->
	      
         <section title="Reconnaissance Phase">
              <t> When a sender resumes transmission between the same pair of endpoints,
          	(aka thinks it uses the same path) it enters the Reconnaissance Phase.
          	The sender only enters this phase when there are saved CC parameters for the same
          	pair of endpoints and this information is currently valid (i.e., the parameters have
         	not expired.)
          	When a method is provided (such as the BDP_Frame), a receiver can request
          	the sender to not enter this phase.</t>
          
          	<t>In the Reconnaissance Phase, the sender transmits initial data, limited by the Initial Window,
		and monitors its reception using the acknowledgements from the receiver.
          	The sender measures the path characteristics of the present
          	path to confirm that the path is consistent with the previously characterized path
          	(including experiencing a similar RTT) <xref target="sec-recon"></xref>.
          	<list>
            		<t>If the sender determines that the current path RTT or the other saved path information
             		are not consistent with the current path,
            		then it reverts to using the standard CC, and enters
            		the Normal Phase.</t>
             		<t>To ensure a sender avoids resuming under severely congested conditions,
	                if any sent initial data
             	 	was not correctly acknowledged or congestion was detected, 
			then the sender also enters the Normal Phase. </t>
            		<t>When the sender has confirmed that the saved and current path information are consistent
            		and also that the sent initial data
            		was acknowledged, it may enter the Unvalidated Phase.
			This transition occurs when the sender is able to send more data than allowed
			by the current cwnd.</t>
          	</list>
          	</t>
		
	  	<t>{XXX-Editor Note: A proportional increase in cwnd/rate: An implementation
		could transition to the Unvalidated Phase when the first initial data has been
		acknowledged and some initial data  is still pending acknowledgedment.
		This would allow each new recived ACK to increase cwnd  
		in proportion to the acknowledged volume of initial data, e.g.,
		cwnd+=(jump_cwnd*(acknowledged_bytes/Initial_Window)).
		Such a proportional method reduces the impact of delayed acknowledgements
		and any pacing of initial data,
		which could otherwise delay the start of transmission using the jump_cwnd.}</t>
         </section> <!-- End of Reconnaissance Phase -->
	      
         <section title="Unvalidated Phase:">
	     <t>This phase utilises paced transmission using an icreased rate/cwnd. A jump_cwnd that is calculated based 
		on the saved CC parameters:</t>
	     <list style="symbols">
 		<t>A 
		To avoid starving other (potential) flows that could have started or increased their capacity
		 after the Observation Phase, the
		jump_cwnd MUST NOT exceed a half of the saved
		capacity.</t>
		 <t>Transmission using an unvalidated cwnd/rate MUST use pacing.</t>
	         <t>A sender monitors the correct reception 
	         of packets that were sent using the unvalidated jump_cwnd:
	        <xref target="sec-unvalid"></xref>. If a sender determines either that the previous parameters
                  are not valid (due to a detected change in the path) or that congestion was experienced,
                  it enters the Safe Retreat Phase.</t>
            </list> <!-- End of list of actions -->
	   
         </section> <!-- End of Unvalidated Phase -->
	      
         <section title="Safe Retreat Phase">
	      
              <t>Ths phase is designed to mitigate the impact on other
              flows that follows while sharing a congested bottleneck 
	      in the Unvalidated Phase:</t>
	      <list>
              	<t>On entry to the phase, any saved CC parameters for 
	       	this path are removed from any cache, to prevent these
              	parameters being used again with other flows.</t>  
	      	<t> The sender re-initializes the flows CC parameters to compensate for
	      	any overshoot in the Unvalidated Phase. 
	      	This is to allow other flows to then regain
              	their share of the available capacity.</t>
	      </list> <!-- End of list of actions -->

	      <t>The following examples provide methods that implement the Safe Retreat Phase:</t>
	      <list>
		 <t>1. A simple conservative approach sets cwnd to 2*IW and performs slow start. 
		The pattern of cwnd growth that would have occurred had the method not been used.<t>
	        <t>2. Better performance can be achieved by tracking the volume of 
		successfully transmitted packets in each RTT (the Pipe). A method can
		use this parameter to update the cwnd:
		A sender MUST set CWND to no more than pipe/2 when entering the Safe Retreat phase. 
	        This adjustment in cwnd ought further be reduced to reflect the size of overshoot 
		(which could have resulted in further loss to sharing flows). 
		Under significant congestion the cwnd must be no more than 2*IW.</t>
		<t>3. A method can discount.</t>

	      </list> (!--- list of examples -->
	      <t>Note: The Safe Retreat reaction differs to a traditional
              CC reaction to congestion, because
	        the jump_cwnd typically results in a higher rate than allowed by a traditional
              slow-start mechanism, aggressively feeding any congested bottleneck.
	      The resulting overshoot could replace the capacity used by packets from other flows. 
	      For this reason, a sender needs to reduce its rate more than normal.</t>
		              
	    <section title="Loss Recovery after entering Safe Retreat">

		<t>There can be packets
              that were sent in the Unvalidated Phase that have not yet been acknowledged 
	      and are declared lost.
              This loss recovery commences using the reduced window that was set on entry to the Safe Retreat Phase.</t

		<t>Note: In the case of multiple loss, recovery can require multiple RTTs to complete,
		 since the Safe Retreat Phase reduces the cwnd on entry..</t>

	     <t>Note: A TCP or SCTP sender is always required to retransmit all lost data.
		For QUIC and DCCP, loss recovery depends on the sender policy for retransmission.</t>
		 
             <t>The sender then enters the Normal phase with the re-initialized CC parameters.</t>
	    </section>     <!-- End of Safe Retreat Phase: loss recovery -->
         </section> <!-- title="Safe Retreat Phase" -->
	      
        <section title="Normal Phase">
            <!-- We need to be careful here of the corner case that sender either did not utilise the jump, or the jump was not successful -->
		<t> The sender MUST reset CWND 
	           on entry to the normal Phase to reflect the volume of
		   acknowledged data that was received during the Unvalidated Phase. 
		   (When the sender has used the entire jump_cwnd and this was acknowledged in full, no adjustment is needed.)</t>
	   <t>In the Normal Phase, the sender continues transmission using the normal CC method.</t>
        </section> <!-- title="Normal Phase:" -->
	    
	<section title="RTO Expiry while using Carefsul Resume">
	     <t>If the sender experiences a Retransmission Time Out (RTO) expiry
	     at any time while using Careful Resume, 
            it returns to the Safe Retreat Phase before it processes the RTO expiry.</t>
        </section> <!-- title="RTO Expiry:" -->
	</section>
	
      <section title="Congestion Control Guidelines and Requirements">
	
        <t>The sender is limited by any rate-limitation of the transport
        protocol being used.</t>
	      
	<t>For QUIC this includes: flow control mechanisms or amplification
        attack prevention. In particular, a QUIC receiver might need to issue proactive
        MAX_DATA frames to increase the flow control limits of a connection
        that is started with this method to gain the expected benefit.<t>
		
	<t>A TCP sender is limited by the receiver window (rwnd).
	Unless configured at a receiver, the rwnd can constrain the rate 
	of increase for a connection and reduce the expected benefit of the method.</t>

        <section anchor="sec-measure" title="Determining the current Path Capacity in the Observe Phase">
			
            <t>There are various approacgs to measuring the capacity that has
	    been used by a connection. 
	    Congestion controllers, such as CUBIC or RENO, can estimate the
            saved_bb and current_bb values by utilizing a combination of the
            cwnd/flight_size and the minimum RTT. A different method could 
	     estimate the same values for a rate-based congestion
            controller, such as BBR <xref target="I-D.cardwell-iccrg-bbr-congestion-control"></xref>.
	   
            <list style="symbols">
                <t>Observe Phase: The sender SHOULD NOT store and/or send CC parameter
                information related to an estimated bottleneck bandwidth
                (saved_bb) (see <xref target="sec-terms_def"></xref> for more
                details on bottleneck bandwidth definition), if the cwnd is not at
                least four times larger than the IW.</t>

                <t>Observe Phase: The sender SHOULD update the stored CC parameters and/or send updated CC parameter
                information related to an estimated bottleneck bandwidth
                (saved_bb) (see <xref target="sec-terms_def"></xref> for more
                details on bottleneck bandwidth definition), if there are significant changes in the CC parameters
                that the session has measured. The rate of the updates transmission SHOULD be limited to at most
                one update for several RTTs of time.</t>
		    
                <t>Observe Phase: There are cases where the current cwnd/rate
                does not reflect the bottleneck bandwidth. At the end of the CC slow
                start phase, the value of cwnd/rate can be significantly larger than
                the minimum value needed to utilize the path (i.e., a cwnd
                overshoot). In most case, the cwnd will finally converge to a stable
                value after several more RTTs. It would be inappropriate to use an
                overshoot in the cwnd as a basis for estimating the bottleneck
                bandwidth. 
		One mitigation could be to calculate the bottleneck 
		bandwidth based on
                the flight_size or an averaged cwnd. 
		At the end of a connection, a sender typically transmits
		much less than allowed by cwnd. This can also happen when a sender
		is application-limited. The bottleneck bandwidth estimate could exclude these
		samples.</t>

            </list></t>
	    
        </section> <!-- Observe Phase  (measure) -->

        <section anchor="sec-recon"  title="Confirming the Path in the Reconnaissance Phase">
            <t>The sender transmits initial data limited by the IW. This value is
            assumed a safe starting point for any path where there is no path
            information or congestion control information to avoid
            adding excessive congestion for a potentially congested path.</t>

            <t>The sender monitors the reception of any initial data. If the path
            characteristics resemble those of a previously observed connection
            (i.e., current_rtt &lt; 1.2*saved_rtt) and
            all data was acknowledged without reported congestion, the
            method permits the sender to utilize the saved_bb as an input to
            adapt the current_bb to rapidly determine a new safe rate.</t>
            <t>
            <list style="symbols">
                <t>Reconnaissance Phase: A sender MUST limit the initial data,
                sent in the first RTT of transmitted data,
                to not more than the
                IW <xref target="RFC9000"></xref>.</t>
            </list></t>

            <t>When used in a controlled
            network, additional information about local path characteristics
            could be known, which might be used to configure a non-standard
            IW.</t>
 
            <section anchor="sec-confirm" title="Confirming the Path">
                 <t>Paths can change with respect to time for many reasons.
                This could result in previously measured CC parameters
                becoming irrelevant.
            
                <list style="symbols">
                    <t>Endpoint Token change: If the Endpoint Token changes
                    (i.e., the saved_endpoint_token is different from the
                    current_endpoint_token), the different Endpoint Token can be assumed as an
                    indication of a different network path. This new path does not
                    necessarily exhibit the same characteristics as the old one.</t>

                     <t>RTT change: Since the CC information
                     is directly impacted by the RTT, a significant change in the RTT
                     is a strong indication that the previously estimated BDP
                     parameters are not valid for the current path.</t>

                    <t>Lifetime of the information: The CC information is temporal.
                    Frequent connections to the same endpoint are likely to track
                    changes, but long-term use of previous values is not appropriate.
		    
		    {Note - a later revisio  may suggest/require cache expiry.}</t>
               
                </list></t>
		<t>{NOTE TBC: The RTT check should be a range rather than an
                inequality (current_rtt &lt; 1.2*saved_rtt).}</t>

                <t>{NOTE: A future revision of this document needs to specify how long
                CC Parameters can be cached, possibly based on TCP-new-CWV or TCB.}

                <t>Reconnaissance Phase:</t><list style="symbols">
                    <t>The sender in the Reconnaissance Phase MUST compare the measured
                    transport parameters (in particular current_rtt) of the new connection
                    with the saved parameters (in particular confirm the
                    saved_rtt is consistent with teh current RTT).
		    The method MUST NOT be used when the path RTT fails to be
                    confirmed.</t>
                    <t>The sender MUST NOT use the parameters
                    if any sent packet in the Reconnaissance Phase is detected as lost or
                    acknowledgments indicate these packets were ECN CE-marked
		    this MUST result in a transition to the Safe Retreat Phase. </t>
                </list></t>    
            </section><!-- Reconnaissance:Confirming the Path"-->
        </section> <!-- Reconnaissance -->

        <section anchor="sec-unvalid" title="Safety Requirements for the Unvalidated Phase">
            <t> This section defines the safety requirements
            for using saved CC parameters to update the cwnd.
            These safety guidelines are designed to mitigate the risk that sender
            adds excessive congestion to an already congested path.</t>
				
            <list style="symbols">
                <t>Unvalidated Phase: A new connection MUST NOT directly use the previously measured saved_rtt and
                saved_bb to simply initialize a new flow to resume sending at the same
                rate. The jump_cwnd MUST be no more than 1/2 the previous saved capacity based on the current RTT (saved BDP/ current RTT).</t>
            </list></t>
					
            <section title="Exit for the Unvalidated Phase because of Variable Network Conditions">
                <t>Unvalidated and Reconnaissance Phases: The method MUST be robust to
            	network conditions that can differ from one connection to the next,
            	due to variations in the forwarding path, reconfiguration of
            	equipment, or changes in the link conditions.</t>
	
                <t><list style="symbols">
		
                <t>Unvalidated Phase: The method MUST be robust to changes in network traffic, including the
            	arrival of new traffic flows that compete for capacity at a shared bottleneck.</t>
			
            	<t>Unvalidated Phase: The method MUST prevent unduly suppressing flows
		that used capacity since the available capacity was measured.
		</t>

                    <t>Unvalidated Phase: The sender MUST transition to the Safe Retreat Phase
                    when a packet loss is detected or acknowledgments indicate sent
                    packets were ECN CE-marked. These are an indication of potential
                    congestion.</t>
                </list></t>
            </section> <!--  Unvalidated Phase:  Network Conditions -->
			
            <section anchor="sec-pace" title="Pacing in the Unvalidated Phase">
		    
                <t> The sender MUST avoid sending a burst of packets greater than IW as a result of a
                step-increase in the congestion window <xref target="RFC8085"></xref>,
                <xref target="RFC9000"></xref>. 
		Pacing sentpackets as a function of
                the current RTT can provide this additional safety during the
                Unvalidated Phase.
                Various other sender mitigatuons have also been suggested to 
		avoid line-rate bursts (e.g., <xref target="I-D.hughes-restart"></xref>).</t>
		    
                <t>The following example provides a relevant pacing rhythm:
    	         The sender estimates a pacing rhythm using saved_rtt and
             		 saved_bb. The Inter-packet Transmission Time (ITT) is determined
              		from the ratio between the current Maximum Message Size (MMS) and
              		the ratio between the saved_bb and saved_rtt. A tunable safety
              		margin can avoid sending more than a recommended maximum IW
              		(recom_iw): 
			<list style="symbols">
                  		<t>current_iw = min(recom_iw,saved_bb)</t>
                  		<t>ITT = MSS/(current_iw/saved_rtt)</t>
                	</list></t>
                <t>This follows the idea presented in <xref target="RFC4782"></xref>,
                <xref target="I-D.irtf-iccrg-sallantin-initial-spreading"></xref> and
                <xref target="CONEXT15"></xref>.</t>
            </section> <!-- Unvalidated Phase: Pacing  -->
        </section> <!-- Unvalidated Phase -->

   <!--     <section anchor="sec-retreat" title="Safety Requirements for the Safe Retreat Phase">
            <t>This section defines the safety requirements
            after a path change or congestion has been detected during the Unvalidated Phase.</t>

            <t>The transport parameters are adjusted in the Unvalidated Phase, resulting in a higher cwnd.
            If there are indications of congestion, this also indicates that the parameters
            no longer reflect the current path, and the cwnd needs to be reduced to avoid
            overshoot of the bottleneck
            capacity. This can result from changes in traffic at the bottleneck and/or
            changes in the path capacity.</t>
	    
            <t>{XXX-Editor note:  Initial text follows:}</t>

	     <t>A CC that records the capacity used (e.g., Pipe) when congestion was detected, needs to update
	     this value (e.g., ssthresh=Pipe/2) before leaving the Safe Retreat Phase. The measured capacity does
	     relect a measured capacity at loss. This not be treated as a measure of the current share available when
	     there was a significant overshoot of capacity, hence the flow needs to be initially limited to less capacity
		(i.e., cwnd < ssthresh).</t>

	    <t>{Add method 3: using cwnd-Pipe to account for overshoot } </t>

        </section><!-- Safety Requirements for the Safe Retreat Phase -->

	<section anchor="sec-normal" title="Returning to Normal Congestion Control">
            <t>After using the method, the CC controller returns to the Normal Phase.
	  
            <list style="symbols">
                <t>For NewReno and CUBIC, it is recommended to exit slow-start
                and enter the congestion avoidance phase.</t>

                <t>For BBR CC, it is recommended to enter the "probe bandwidth"
                state.</t>
            </list></t>
	     <t>{XXX-Editor note: This should discuss updating 
	  the saved values, whether used or not, after reaching normal operation for use 
	  the next time even if that update is to just refresh the expiration time.}</t>
        </section><!-- End of normal-->
    </section> <!--  Guidelines -->

    <section anchor="sec-acknowledgments" title="Acknowledgments">
      <t>The authors would like to thank John Border, Gabriel Montenegro, Patrick McManus,
      Ian Swett, Igor Lubashev, Robin Marx, Roland Bless, Franklin Simo, Raffaello Secchi for
      their fruitful comments on earlier versions of this document.</t>
      <t>The authors would like to particularly thank Tom Jones for co-authoring 
      previous versions of this document.</t>
    </section>

    <section anchor="sec-IANA" title="IANA Considerations">
      <t>No current parameters are required to be registered by IANA.</t>
    </section>

    <section anchor="sec-security" title="Security Considerations">
        <t>This document does not exhibit specific security considerations. 
	Security considerations for the 
	interactions with the receiver are discussed in <xref
        target="I-D.kuhn-quic-bdpframe-extension"></xref>.</t>
    </section> <!-- Sec Considerations -->
	    
</middle>

  <!--  BACK MATTER -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
(for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
Both are cited textually in the same manner: by using xref elements.
If you use the PI option, xml2rfc will, by default, try to find included files in the same
directory as the including file. You can also define the XML_LIBRARY environment variable
with a value containing a set of directories to search.  These can be either in the local
filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?>

      <?rfc include="reference.RFC.4782.xml"?>

      <!-- <?rfc include="reference.RFC.6349.xml"?> -->

      <?rfc include="reference.RFC.8085.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>

      <?rfc include="reference.RFC.8801.xml"?>

      <?rfc include="reference.RFC.9000.xml"?>
      <?rfc include="reference.RFC.9040.xml"?>

      <!-- <?rfc include="reference.RFC.9001.xml"?> -->

    </references>

    <references title="Informative References">
      	<?rfc include="reference.I-D.irtf-iccrg-sallantin-initial-spreading.xml"?>
      	<?rfc include="reference.I-D.hughes-restart.xml"?>
	<?rfc include="reference.I-D.cardwell-iccrg-bbr-congestion-control.xml"?>
      	<?rfc include="reference.I-D.kuhn-quic-bdpframe-extension.xml"?>
	    
      <?rfc include="reference.RFC.5783.xml"?>
      <?rfc include="reference.RFC.8867.xml"?>
      
      <reference anchor="MAPRG111">
        <front>
          <title>Feedback from using QUIC's 0-RTT-BDP extension over SATCOM
          public access</title>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Stephan"></author>

          <author initials="G" surname="Fairhurst"></author>

          <author initials="T" surname="Jones"></author>

          <author initials="C" surname="Huitema"></author>

          <date year="2022" />
        </front>

        <seriesInfo name="IETF 111 - MAPRG meeting" value="" />
      </reference>

      <reference anchor="IJSCN">
        <front>
          <title>Google QUIC performance over a public SATCOM access</title>

          <author initials="L" surname="Thomas"></author>

          <author initials="E" surname="Dubois"></author>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Lochin"></author>

          <date year="2019" />
        </front>

        <seriesInfo name="International Journal of Satellite Communications and Networking"
                    value="10.1002/sat.1301" />
      </reference>

      <reference anchor="CONEXT15">
        <front>
          <title>Halfback: Running Short Flows Quickly and Safely</title>

          <author initials="Q" surname="Li"></author>

          <author initials="M" surname="Dong"></author>

          <author initials="P B" surname="Godfrey"></author>

          <date year="2015" />
        </front>

        <seriesInfo name="ACM CoNEXT" value="" />
      </reference>
    </references>

<section anchor="endpoint_token" title="Appendix: An Endpoint Token">

    <t>
    This annex proposes an Endpoint Token to allow a sender to identify its own
		    view of the network path that it is using. In <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>
	    this Endpoint Token could be shared and used as an
    opaque path identifier to other parties and the sender can verify if
    this is one of its current paths.
    </t>

    <section title="Creating an Endpoint Token">
        <t>
        When computing the Endpoint Token, the sender includes information to identify
        the path on which it sends, for example:
        <list style="symbols">
	    <t>
            it needs to include a unique identifier for itself (e.g., a globally
            assigned address/prefix; or randomly chosen value).
	    </t>
	    <t>
            it needs to include an identifier for the destination (e.g., a
            destination IP address or name).
	    </t>
	    <t>
            it needs to include an interface identifier (e.g., an index value or a MAC address to associate the
            endpoint with the interface on which the path starts);
	    </t>
	    <t>
            it could include other information such as the DSCP, ports, flow
            label, etc (recognising that this additional information might improve the path
            differentiation, but that this can can reduce the re-usability of the
            token);
	    </t>
	    <t>
            it could include any other information the sender chooses to
	    include, and potentially including PvD information <xref target="RFC8801"></xref> or
            information relating to its public-facing IP address;
	    </t>
	    <t>
            it could include a nonce;
	    </t>
	    <t>
            it could include a time-dependent value to define the validity
            period of the token.
	    </t>
       </list></t> 

        <t>
        When creating an Endpoint Token, the sender has to ensure the following:
        <list style="numbers">
	    <t>
            To reduce the likelihood of misuse of the Endpoint Token, the value
            ought to be encoded in a way that hides the component information
	    from the recipient and any eavesdropper on the path.
            </t>
	    <t>
            The sender can recalculate the Endpoint Token if it needs to validate a
            previously issued token; and that the Endpoint Token itself can be
            included in the computed integrity check for any path
            information it provides.
	    </t>
	    <t>
            The Endpoint Token is designed so that if shared, it prevents another party from deriving
            private data from the token, or to use the token to perform
            unwanted likability with other information. This implies that
            the Endpoint Token MUST necessarily be different when used to identify
            paths using different interfaces.
            </t>
       </list> </t>
    </section>

 </section> <!-- End of An Endpoint Token -->
	  
<section title="Summary">

          <figure anchor="fig-summary" title="Comparing Careful Resume solutions">
            <artwork><![CDATA[
+---------+-----------+----------------+---------------+-----------+
|Rationale| Solution  |    Advantage   |    Drawback   |  Comment  |
+---------+-----------+----------------+---------------+-----------+
|#1       |#1         |                |               |           |
|Variable |set        |Ingress optim.  |Risk of adding |MUST NOT   |
|Network  |current_*  |                | congestion    |implement  |
|         |to saved_* |                |               |           |
|         +-----------+----------------+---------------+-----------+
|         |#2         |                |               |           |
|         |Implement  |Reduce risk of  |Negative impact|MUST       |
|         |safety     | adding         | on ingress    |implement  |
|         |check      | congestion     | optim.        |Section 3  |
+---------+-----------+----------------+---------------+-----------+


]]></artwork>
</figure>
	
<!-- text relating to BDP Frame moved out of this draft -->
		
</section> <!-- end of Summary -->
<section anchor="rev" title="Appendix: Revision details">
<t>Previous individual submissions were discussed in TSVWG and QUIC.</t>
<list>
<t>WG -00 included clarifications and restructuring to form the 1st WG draft.</t>
<t>WG -01 included review comments and suggestions from John Border, 
	and follows the setting of the TSVWG milestone 
	with an intended status of "Proposed Standard".</t>
</list>
</section> <!-- end of Revisions -->

</back>
</rfc>
