<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-tsvwg-careful-resume-02"
     ipr="trust200902">
    <!-- category values: std, bcp, info, exp, and historic
    ipr values: full3667, noModification3667, noDerivatives3667
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

    <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header
     - it is only necessary if the
full title is longer than 39 characters -->

    <title abbrev="Careful Congestion Control Convergence">Careful Convergence of Congestion
    Control from Retained State</title>

    <author fullname="Nicolas Kuhn" initials="N" surname="Kuhn">
      <organization>Thales Alenia Space</organization>
      <address>
        <email>nicolas.kuhn.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Emile Stephan" initials="E" surname="Stephan">
      <organization>Orange</organization>
      <address>
        <email>emile.stephan@orange.com</email>
      </address>
    </author>

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>Department of Engineering</street>
          <street>Fraser Noble Building</street>
          <city>Aberdeen</city>
          <code>AB24 3UE</code>
          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Christian Huitema" initials="C" surname="Huitema">
      <organization>Private Octopus Inc.</organization>

      <address>
        <email>huitema@huitema.net</email>
      </address>
    </author>

    <date year="2023" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
in the current day for you. If only the current year is specified, xml2rfc will fill
in the current day and month for you. If the year is not the current one, it is
necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
purpose of calculating the expiry date).  With drafts it is normally sufficient to
specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

     <!-- WG name at the upperleft corner of the doc,
     IETF is fine for individual submissions.
     If this element is not present, the default is "Network Working Group",
     which is used by the RFC Editor as a nod to the history of the IETF. -->

     <keyword>Transport, Congestion Control, QUIC</keyword>

    <!-- Keywords will be incorporated into HTML output
     files in a meta tag but they have no effect on text or nroff
     output. If you submit your draft to the RFC Editor, the
     keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies a cautious method for IETF transports that
      enables fast startup of congestion control for a wide
      range of connections or reconnections.</t>
      <t>The method reuses a set of computed congestion control parameters that
      are based on previously observed path characteristics between
      the same pair of transport endpoints. These parameters
      are stored, allowing them to be later used to modify the congestion control behavior
          of a subsequent connection.</t>
      <t>The document discusses assumptions
      and defines requirements around how a
      sender utilizes these parameters to provide opportunities for a
      connection to more rapidly get up to speed and rapidly utilize available
      capacity. It discusses how the method impacts the capacity at a
      shared network bottleneck and the safe response that is needed after any
      indication that the new rate is inappropriate.</t>
    </abstract>
  </front>

<middle>
<section anchor="sec:introduction" title="Introduction">
    <t>All Internet transports are required to either
    use a Congestion Control (CC) method, or
    to constrain their rate of transmission <xref target="RFC8085"></xref>. In 2010,
    a survey of alternative CC methods <xref target="RFC5783"></xref>, noted that there
    are challenges when a CC method operates across an Internet path with a high and/or
    variable bandwidth-delay product. This mechanism targets a
    solution for these challenges.</t>

    <t>A CC method typically takes time to ramp-up the sending rate,
    called the "slow-start phase", informally known as the time to "Get up
    to speed". This slow-start phase defines a time in which a sender
    intentionally uses less capacity than might be available, with the
    intention to avoid or limit overshooting the available capacity for the path.
    The slow-start design can increase queuing (latency/jitter) and/or
    congestion packet loss to the flow. Any overshoot can have a
    detrimental effect on other flows sharing a common bottleneck. In the
    extreme case, persistent congestion could result in unwanted starvation of
    other flows <xref target="RFC8867"></xref> (i.e., preventing other flows
    from successfully sharing capacity at a common bottleneck).</t>

    <t>This document proposes a method that is expected to reduce the time to complete a transfer
    when the transfer sends significantly more data than allowed by the
    Initial congestion window (IW), and
    where the Bandwidth Delay Product (BDP) is also significantly
    more than the product of the IW and the Round Trip Rime (RTT).</t>
    <t>It introduces an alternative method to select initial CC parameters,
    that seek to more rapidly and safely grow the sending rate (or congestion
    window, CWND).
    This method is based on temporal sharing (sometimes known as
    caching) of a saved set of CC parameters that relate to previous observations
    of the same path. The saved CC parameters include:
    the available capacity found on the path, and RTT. These
    parameters are stored and used to modify the CC
    behavior of a subsequent connection between the
    same endpoints.</t>

    <t>When used with the QUIC transport, this provides transport services that resemble
    those currently available in TCP, using methods such as TCP Control Block (TCB)
    <xref target="RFC9040"></xref> caching.</t>

    <section title="Use of saved CC parameters by a Sender">
        <t>CC parameters are used by this method for two functions:
        <list style="symbols">
            <t>Information about the utilised path capacity.
            This allows a later sender to
            determine an appropriate set of CC parameters for re-using the path.</t>
            <t>Information to characterize the saved path that allow a sender to
            confirm whether the current path
            is consistent with a saved path.</t>
        </list></t>
           
            <t>"Generally, implementations are advised
            to be cautious when using previous values on a new path",
            as stated in <xref target="RFC9000"></xref>.
            While this statement has been proposed in the context of QUIC standardization, this advice is appropriate for any IETF transport protocol.
            Care is therefore needed
            to assure safe use and to be robust to changes
            in traffic patterns, network routing and link/node conditions.
            There are cases where using the saved parameters of a previous
            connection is not appropriate.</t>
    </section>  <!-- End of use with care -->
          
    <section title="Receiver Preference">
            <t>Whilst a sender could take optimization decisions without considering
            the receiver's preference, there are cases where a receiver
            could have information that
            is not available at the sender, or might benefit from
            understanding that careful resume might be used. In these cases, a receiver
            could explicitly ask to enable or inhibit tuning of the CC
            when an application initiate a new session or resume an existing one.</t>
            
            <t>An indication from the sender that the method is available, could also
            allow a receiver to tune policies for using the connection (e.g., managing the
            receiver window or flow credit).</t>
            <t> Examples where a receiver could request not to use the method include:
            <list style="numbers">
                <t>a receiver that can predict the pattern of traffic
                (e.g., insight into the volume of data to be sent,
                the expected length of a session, or the maximum transfer rate required);</t>
                <t>a receiver with a local indication that a path/local
                interface has changed since the CC parameters were stored;</t>
                <t>knowledge of the current hardware limitations at a receiver;</t>
                <t>a receiver that can predit additional capacity will be needed
                for other concurrent/later flows
                (i.e., prefers to use the method for the other flows).</t>
        </list></t>

            <t>QUIC introduces the concept of transport parameters (Section 4 of
                <xref target="RFC9000"></xref>).
            A related document proposes an exchange for QUIC that requests
            the sender-generated CC parameters to be stored at the receiver
            <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>.
            Transferring the information to a receiver releases the need for a
            sender to retain transport state for each
            receiver. This document also evaluates the potential
            for malicious use of this exchange.</t>
    </section> <!-- End of Receiver Preference -->

    <section anchor="sec-use_case" title="Examples of Scenarios of Interest">

        <t> This section provides a set of examples where the method is expected to improve performance.</t>

        <t>Either endpoint can assume the role of a
        sender or a receiver. The method also supports a bidirectional data transfer,
        where both endpoints simultaneously send data (e.g., remote execution of an application, or a
        bidirectional video conference call).</t>

        <t>In one example, an application uses a series of connections over a path
        (i.e., resumes a connection to the same endpoint).
        Without this method,
        each connection would need to individually
        discover appropriate CC parameters, whereas the method allows the flow
        to continue at a rate that resembles the previous rate.</t>

        <t>In another example, an application reconnects after a disruption
        had temporarily reduced the path
        capacity (e.g., after a link propagation
        impairment, or where a user on a train journey travels through
        different areas of connectivity). When the endpoint
        returns to use a path with the original characteristics, it can resume
        a transmssion rate based on the previously measured characteristics.</t>

        <t>
        There is particular benefit for
        any path with an RTT that is much larger than for typical
        Internet paths.
        In a specific example, an application connected via a satellite access network
        <xref target="IJSCN"></xref>
        could require 9 seconds to complete a 5.3 MB transfer
        using standard CC, whereas using the
        method this transfer time could reduce to 4 seconds. The time to complete a 1 MB transfer could
        dimilarly reduce by 62 % <xref target="MAPRG111"></xref>. This benefit is also
        expected for other sizes of transfer and for different path
        characteristics when a path has a large BDP.</t>

        <t>{XXX-Editor note: A future revision would helpfully provide further Path Examples here.}</t>
    </section> <!-- Introduction: End of examples -->
   
</section> <!-- End of introduction and motivation -->

<!-- ****************************************************************************************** -->
<!-- The protocol spec follows below here, examples later -->

<section anchor="notation" title="Language, Notation and Terms">

    <t>This subsection provides a brief summary of key terms and the
    requirements language that is used.</t>

    <section anchor="sec:req_language" title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
         "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
         "OPTIONAL" in this document are to be interpreted as described in
         BCP 14
         <xref target="RFC2119"/>
         <xref target="RFC8174"/>
         when, and only when, they appear in all
         capitals, as shown here.</t>
    </section>

    <section anchor="sec-terms_def" title="Notation and Terms">
        <t> The document uses language drawn
        from a range of IETF RFCs.  It defines current, and saved values for a set of CC
        parameters:
        <list>

            <!-- GF (Feb 2023): Removed the IW from this information block??? -->
            <!-- it could potentially be in BDP but is not needed here -->
            <!--    <t>IW: Initial Window <xref target="RFC9002"></xref>;</t> -->
            <!--            <t>current_iw: Current IW;</t> -->
            <!--            <t>recom_iw: Recommended IW;</t> -->

            <t>current_capacity : The currently utilised path capacity;</t>

            <t>saved_capacity: The capacity preserved from a
            previous connection;</t>

            <t>recom_jump : The maximum configured jump_size;</t>

            <t>current_rtt: A sample measurment of the current RTT;</t>

            <t>saved_rtt: The preserved minimum RTT, corresponding to the minimum
            of a set RTT measurements taken at the time when the
            saved_capacity was estimated;</t>

            <t>endpoint_token: An Endpoint Token for a receiver;</t>

            <t>current_endpoint_token: The current Endpoint Token of the receiver;</t>

            <t>saved_endpoint_token: The Endpoint Token of a previous connection by the
            receiver;</t>

            <t>jump_cwnd: The resumed CWND, used in the Unvalidated Phase.</t>
            <t>Pipe: The estimated available capacity at the time of congestion.</t>
        </list>
        </t>

        <t>The Endpoint Token is described in <xref target="endpoint_token"></xref>.
        </t>

    </section> <!-- End of Notation: End of terms -->
</section><!-- End of Notation -->

<section anchor="sec-phase" title="The Phases of CC using Careful Resume">
    <t>This section defines a series of phases that the
    CC algorithm moves through as a connection
    uses the Careful Resume method, as shown in Figure 1.</t>

   <t>
 <artwork align="left" name="" type="" alt=""><![CDATA[
     
Connect -> Reconaissance --------------------> Normal
             |                                   ^
           Unvalidated --> Validating -----------+
             |               |                   |
             +---------------+-> Safe Retreat ---+
     
 ]]></artwork>
</t>

<t> Figure 1: The phases in setting up a connection using the Careful Resume method. The Observe Phase
is later performed by an established connection.</t>
     
    <!-- These subsections to match next section format -->
    <section title="Observe Phase">
        <t>During a previous connection, information about the specific path
        to an endpoint is saved. This is used to characterize the path and
        to measure the capacity that was used. This includes the minimum RTT
        (saved_rtt), the path capacity (saved_capacity) and the receiver
        Endpoint Token (saved_endpoint_token). An implementation
        can store this information at the server (or could exchange this information
        with a receiver, as detailed in <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>).</t>
        <t><list>
        <t>Observe Phase: If the measured CWND is less than four times the IW
            (or the rate is less than would be permitted by IW*4/RTT),
            a sender SHOULD NOT store and/or send CC parameter
            information.</t>
    </list></t>

    </section> <!-- End of define Observe Phase:-->
          
    <section anchor="rec-phase" title="Reconnaissance Phase">
        <t> When a sender resumes transmission between the same pair of endpoints,
        (a.k.a. thinks it uses the same path) it enters the Reconnaissance Phase.
        The sender only enters this phase when there are saved CC parameters for the same
        pair of endpoints and this information is currently valid (i.e., the saved parameters have
        not expired.)
        When a method is used (such as the BDP_Frame), a receiver can request
        the sender to not enter this phase.</t>

        <t>In this phase, the sender transmits initial data, limited by the IW,
        and monitors its reception.
        This phase measures the current path characteristics
        to confirm these are consistent with the previously characterized path.

        <list style="symbols"> <!-- list of phase -->
            <t>Reconnaissance Phase (Endpoint change):
            If the current endpoint is not the same,
            the sender MUST revert to using the standard CC, and enters
            the Normal Phase. If the Endpoint Token changes
            (i.e., the saved_endpoint_token is different from the
            current_endpoint_token), it is assumed to represent a different network path.</t>

             <t>Reconnaissance Phase (RTT change): Since the CC information
             is directly impacted by the RTT, a significant change in the RTT
             is a strong indication that the previously estimated BDP
             parameters are not valid for the current path.
             An RTT measurement is confirmed when current_rtt &ge;
             (saved_rtt / 2) and the current_rtt  &le;  (saved_rtt x 10 (TBC)).</t>

            <t>Reconnaissance Phase (Lifetime of saved information): The CC information is temporal.
            Frequent connections to the same endpoint are likely to track
            changes, but long-term use of previous values is not appropriate.</t>

            <!-- A future version may say how many samples are needed?
             Reconnaissance Phase (Number of required samples): ????  -->
        </list></t>

        <t>When a sender confirms the path and it
        receives an acknowledgement for the initial data without reported congestion,
        it MAY then enter the Unvalidated Phase.
        This transition occurs when a sender has more data than permitted
        by the current CWND.</t>

        <t>Implementation requirements are provided in <xref target="req-recon"></xref>.</t>

        <t>When the path is not confirmed, the method is not used
        and the sender enters the Normal Phase.</t>

    </section> <!-- End of Reconnaissance Phase -->
     
    <section anchor="unv-phase" title="Unvalidated Phase">
        <t>The Unvalidated Phase is designed to enable the rate/CWND
        to more rapidly get up to speed, but this require data to send.
         If the application is data limited, the sender sends insufficient data
        to be able to validate the tentative higher rate.
        The method therefore remains in the Reconnaissance Phase and does not
        transition to the Unvalidated Phase until the sender
        has more data ready to send in the transmission buffer
        than is permitted by the current CWND.
        In some implementations, this might require coordination with the management
        of buffers in the interface to the higher layers.</t>

        <t>This phase paces transmission using an increased rate/CWND (jump_cwnd)
        that is calculated based on the saved CC parameters and current_RTT.</t>
        <t><list style="symbols">
             <t>Unvalidated Phase (jump_size):
             To avoid starving other (potential) flows that could have started
             or increased their capacity after the Observation Phase,
             the jump_cwnd MUST be no more than half of the previous saved_capacity.
             Hence, jump_cwnd &le; saved_capacity/2.</t>
             
             <t>Unvalidated Phase (Pacing): Transmission using an unvalidated
             rate/CWND MUST use pacing.</t>
             
             <t>Unvalidated Phase (Confirming the path):
             If a sender determines that the previous parameters
             are not valid (due to a detected change in the path)
             (e.g. packet delay has changed), the method enters the
             Safe Retreat Phase.</t>
             <t>The sender enters the Validating Phase when an acknowledgement is
             received for the firt packet number (or higher) sent in the Unvalidated Phase.
         </t>
        </list></t> <!-- End of list of actions -->

        <t>Implementation requirements are provided in <xref target="req-unvalid"></xref>. </t>
    </section> <!-- End of define Unvalidated Phase -->

    <section anchor="val-phase" title="Validating Phase">
        <t>The Validating Phase is designed to verify that the packets
    sent in the Unvalidated Phase were received without inducing congestion.
    The sender typically remains in this phase for 1 RTT.
    The CWND remains unvalidated in this phase. (Note: When the full jump_cwnd is not
    fully utilised, this results in s smaller capcity being validated.)
        </t>

        <t><list style="symbols">
        <t>Validating Phase (Updating CWND): The CWND is updated using the 
         normal rules for the current congestion controller. The default 
         rule is that of Reno. 
        <t>Validating Phase (Validating the capacity):
             A sender monitors the correct reception
             of the packets that were sent using the unvalidated jump.
             If a sender determines that congestion was experienced 
             (e.g., packet loss or ECN-CE marking), the method enters the
             Safe Retreat Phase.</t>
        <t>The sender enters the Normal Phase when an acknowledgement is
             received for the last packet number (or higher) that was sent
         in one RTT after
             entering the Unvalidated Phase.</t>

        </list></t> <!-- End of list of actions -->
    </section> <!-- End of define Validating Phase -->
    
    <section anchor="ret-phase" title="Safe Retreat Phase">

      <t>This phase is entered when a jump in the
      Unvalidated Phase has overshot the currently available capacity.
      The phase starts when the first loss/ECN-CE marking is detected.
      This trigger is the same as used by QUIC sender to transition
      from Slow Start to Recovery <xref target="RFC9002"></xref>.</t>
         
      <t><list style="symbols">
            <t>Safe Retreat Phase (Saved information): Any saved CC parameters for
            this path are removed from any cache, to prevent these
            parameters being used again with other flows.</t>
            <t>Safe Retreat Phase (Re-initializing CC): On entry,
        the CWND MUST be reduced to
            no more than the Initial Window.
            This avoids persistent starvation by helping other flows to regain
            their share of the available capacity.</t>
        <t>Safe Retreat Phase (QUIC recovery): When the CWND is reduced,
        a QUIC sender can immediately send a single packet prior to reduction
        <xref target="RFC9002"></xref>.
        This speeds up loss
            recovery if the data in the lost packet is retransmitted and is
             similar to TCP as described in Section 5 of <xref target="RFC6675"></xref>.</t>
         <t>Safe Retreat Phase (Incresing cwnd):
         The CWND MAY be increased for each acknowledgment that acknowledges a
         previously unacknowleded packet that was sent in the Unvalidated Phase,
         since this indicates
             the packet has been successfully sent across the network path.</t>
         <t>The Safe Retreat Phase ends and the sender enters Normal Phase
            when the last packet (or later) sent during the
         Unvalidated Phase is acknowledged.</t>

    </list></t>
     
    <t><list>
          <t>NOTE: The Safe Retreat reaction must differ from a traditional
          reaction to detected congestion, because
          the jump_cwnd can result in a significantly higher rate than would be allowed by the
          slow-start mechanism. This could aggressively feed a congested bottleneck,
          resulting in overshoot where a disproportionate number of packets
          from existing flows are displaced from
          the buffer at the congested bottleneck.
          For this reason, a sender needs to reduce its rate/CWND significantly
          below the observed bandwidth.</t>
    </list></t>
          
         <t>Implementation requirements are provided in
         <xref target="req-retreat"></xref>.</t>

         <section anchor="loss" title="Loss Recovery after entering Safe Retreat">

            <t>Unacknowledged packets that were sent in the Unvalidated Phase
            can be lost when there is congestion.
            Loss recovery commences using the reduced CWND
            that was set on entry to the Safe Retreat Phase.
            <!--The way CWND is updated
             is different from the design for TCP <xref target="RFC5681"></xref>
            and from QUIC Loss Detection and Congestion Control <xref target="RFC9002"></xref>.-->
            </t>

            <t><list>
                 <t>NOTE: A TCP or SCTP sender is always required to retransmit
                 all lost data.
                 For QUIC and DCCP, the need for loss recovery
                 depends on the sender policy for retransmission.</t>
                
                 <t>NOTE: During loss recovery, a receiver can cumulatively acknowledge
                 data that was previously sent in the Unvalidated Phase in addition
                 to acknowledging successful retransmission of data.
                 <xref target="RFC3465"></xref> describes how to appropriately
                 account for such acknowledgments.</t>
            
                <t>NOTE: On entry to the Safe Retreat Phase, the rate/CWND can be
                significantly reduced, when there was multiple loss,
                recovery of all lost data could require multiple RTTs to complete.</t>
        </list></t>

            <t>The sender leaves the Safe Retreat Phase when an acknowledgement is
            received for the last packet number (or higher) sent in the Unvalidated Phase.
            If the last packet number is not cumulatively acknowledged, then
            additional packets might need to be retransmitted.<t>

            <t> Methods using a slow-start threshold need to update this
            threshold using the CWND
            (i.e.,  ssthresh = CWND).</t>

            <t>The Normal Phase is then entered.</t>

         </section>     <!-- End of Safe Retreat Phase: loss recovery -->
    </section> <!-- End of Safe Retreat Phase -->

            <section anchor="Normal_Phase" title="Normal Phase">
        <!-- We need to be careful here of the corner case that sender either did not
        utilise the jump, or the jump was not successful -->

        <t>In the Normal Phase, the sender transitions to using the normal CC method
     (e.g., in congestion avoidance).

        <list style="symbols">

            <t>Normal Phase (Updating CC): The sender MUST reset the rate/CWND
            on entry to the Normal Phase to reflect the volume of
            acknowledged data that was received during the Unvalidated Phase.
            (When the sender has used the entire jump_cwnd and this was acknowledged
            in full, no adjustment is needed.)</t>
        </list></t>
        <t>Implementation requirements are provided in <xref target="req-normal"></xref>.</t>

        </section> <!-- End of define "Normal Phase:" -->
        
    <section title="RTO Expiry while using Careful Resume">
        <t>A sender that experiences a Retransmission Time Out (RTO) expiry
        while using Careful Resume, ceases to use the method.
        The sender continues using normal CC.
        
        <list>
             <t>NOTE: As in loss recovery, data sent in the
             Unvalidated Phase could be acknowledged after RTO
             (see <xref target="loss"></xref>).</t>
        </list></t>
    </section> <!-- End of RTO Expiry -->
</section>

<!-- ****************************************************************************************** -->
<!--- Here we provide guidance and requirements on implementation     -->
    
<section title="Congestion Control Guidelines and Requirements">

    <t>This section provides requirements for implementation and guidance on use.</t>

    <section anchor="req-observe" title="Determining the Current Path Capacity in the Observe Phase">
            
        <t>There are various approaches to measuring the capacity that has
        been used by a connection.
        Congestion controllers, such as CUBIC or RENO, can estimate the
        capacity by utilizing a combination of the
        CWND/flight_size and the minimum RTT. A different approach could
        estimate the same values for a rate-based congestion
        controller, such as BBR <xref target="I-D.cardwell-iccrg-bbr-congestion-control"></xref>.
       
        <list style="symbols">
            <!-- Avoid unhelpful use of the method for small CWNDs.-->
            <t>Observe Phase: The sender should update the stored CC parameters
        and/or send updated CC parameter
            information related to an estimated path capacity
            (saved_bc) after each observation.</t>
            <t>Observe Phase: The stored CC parameters should be updated
            if there are significant changes in the saved CC parameters.
            The rate of update MUST be less than
            one update for several RTTs of time.</t>

            <t>Observe Phase: There are cases where the current rate/CWND
            does not reflect the path capacity. At the End of the CC slow
            start phase, the value can be significantly larger than
            needed to fully utilize the path (i.e., a CWND
            overshoot). It is inappropriate to use an
            overshoot in the rate/CWND as a basis for estimating the
            capacity. In most case, the rate/CWND will converge to a stable
            value after several more RTTs.
            One mitigation could be to calculate the
            capacity based on
            the flight_size or an averaged rate/CWND. Also when the sender
            is application-limited or in an RTT following a burst of
            transmission, a sender typically transmits
            much less data than allowed. This case also ought to be discounted when
            estimating the capacity.</t>
        </list></t>
    </section> <!-- Observe Phase  (measuring) -->

    <section anchor="req-recon"  title="Confirming the Path in the Reconaisance Phase">
        <t>In the Reconaisance Phase a sender initates a connection
        and starts sending initial data.
        It measures the RTT to confirm the path it wishes to use.</t>

        <t>A sender must limit the initial data,
            sent in the first RTT of transmitted data,
            to not more than the IW <xref target="RFC9000"></xref>.
        This transmission using the IW is
        assumed to be a safe starting point for any path to avoid
        adding excessive load to a potentially congested path.
        any initial data. (When used in a controlled
        network, additional information about local path characteristics
        could be known, which might be used to configure a non-standard
        IW.)</t>

        <section anchor="sec-confirm" title="Confirming the Path">
            <t>Paths can change with respect to time for many reasons.
            This could result in previously measured CC parameters
            becoming irrelevant. The sender confirms the RTT by comparing each of a
                series of measured RTT samples against
                the previously saved_RTT.</t>
                
             <t>A current RTT sample that is less than a half of the
             saved_RTT is regarded as too small, such a low RTT is indicative of a path change.
             (This factor of two arises, since the rate should not exceed the previous rate when
             the bandwidth was measured, because the jump_cwnd is calculated as 1/2 x
             measured bandwidth.) An RTT sample more than ten times the
             saved_RTT is regarded as too large, such a high RTT is indicative of a path change.
             (The factor of ten accommodates both increases in latency from buffering
             on a path, and the variation between samples.</t>

        <t> NOTE: Some transport protocols implement methods that detect potential congestion
        by inferring congestion from an increase in the RTT.
        In the Reconnaissance Phase, this indication occurs earlier than congestion
        which is reported by
        loss or by ECN marking. Designs need to consider if this is
        a suitable trigger for changing the phase.</t>
        </section> <!-- End of Reconnaissance:Confirming the Path -->
    </section> <!-- End of Reconnaissance(req-recon) -->

    <section anchor="req-unvalid" title="Safety Requirements for the Unvalidated Phase">
            <t> This section defines the safety requirements
            for using saved CC parameters to tentatively update the rate/CWND.
            These safety guidelines mitigate the risk that a sender
            adds excessive congestion to an already congested path.</t>
                    <t>{XXX-Editor NOTE: A future revision of this document needs to specify how long
        CC Parameters can be cached, possibly based on TCP-new-CWV or TCB, RFC9040.}</t>

        <t>
            <list style="symbols">
                <t>Unvalidated Phase: A connection MUST NOT directly use the previously measured saved_rtt and
                    saved_capacity to simply initialize a new flow to resume sending at the same
                    rate. The jump_cwnd must be no more than 1/2 the previous saved capacity based on the
                    current RTT (saved_BDP / current_RTT). Using the current_rtt rather than a saved RTT value
                    helps to ensure appropriate pacing, but places a limitation on the minimum acceptable RTT
                for using the method to avoid sending at a rate higher than previously observed.</t>
        </list></t>
    
        <section title="Exit for the Unvalidated Phase because of Variable Network Conditions">
                <t>Unvalidated and Reconnaissance Phases: The method MUST be robust to
                network conditions that are different
                due to variations in the forwarding path, reconfiguration of
                equipment, or changes in the link conditions.</t>
    
                <t><list style="symbols">
                    <t>Unvalidated Phase: The method MUST be robust to changes
                        in network traffic, including the
                     arrival of new traffic flows that compete for capacity at a shared bottleneck.</t>
                <t>Unvalidated Phase: The method MUST prevent unduly suppressing flows
                that used the capacity since the available capacity was measured.</t>

                    <t>Unvalidated Phase: The sender MUST transition to the Safe Retreat Phase
                    when a packet loss is detected or acknowledgments indicate sent
                    packets were ECN CE-marked. These are an indication of potential
                    congestion.</t>
                </list></t>
        </section> <!--  Unvalidated Phase:  Network Conditions -->
            
        <section anchor="req-pace" title="Pacing in the Unvalidated Phase">
            
            <t> The sender must avoid sending a burst of packets greater than IW as a result of a
            step-increase in the congestion window <xref target="RFC8085"></xref>,
            <xref target="RFC9000"></xref>.
            Pacing sent packets as a function of
            the current RTT provides an additional safety during the
            Unvalidated Phase.
            Other sender mitigatuons have also been suggested to
            avoid line-rate bursts (e.g., <xref target="I-D.hughes-restart"></xref>).</t>

            <t>The following example provides a relevant pacing rhythm:
            The sender estimates a pacing rhythm using the RTT and the
            saved_capacity. The Inter-packet Transmission Time (ITT) is determined
            from the ratio between the current Maximum Message Size (MMS) and
            the ratio between the saved_capacity and the RTT. A safety
            margin can avoid sending more than a recommended maximum
            (recom_jump):
            <list>
                <t>jump_cwnd = min(recom_jump,saved_capacity/2)</t>
                <t>ITT = MSS/(jump_cwnd/saved_rtt)</t>
            </list></t>
            <t>This follows the idea presented in <xref target="RFC4782"></xref>,
            <xref target="I-D.irtf-iccrg-sallantin-initial-spreading"></xref> and
            <xref target="CONEXT15"></xref>.</t>
        </section> <!-- Unvalidated Phase: Pacing  -->
    </section> <!-- Unvalidated Phase -->

     <section anchor="req-val" title="Safety Requirements for the Validating Phase">
    <t>When a sender completes the unvalidated phase, either by sending the jump_cwnd
    or after 1 RTT, it then awaits reception of the acknowledgments to validate the
    use of this capacity.</t>
     </section> <!-- Validating Phase -->

    <section anchor="req-retreat" title="Safety Requirements for the Safe Retreat Phase">

         <t>This section defines the safety requirements
        after congestion has been detected during the Unvalidated Phase.</t>
            
    <t>Note: Proportional Rate Reduction (PRR) assumes that it is safe to reduce
    the rate gradually when in congestion avoidance.
    The method specified for PRR <xref target="RFC6937"></xref> is therefore not appropriate
    when there might be significant overshoot in the use of the capacity.</t>

    <t> The CWND is reduced on entry to the Safe Retreat Phase to
        no more than the Initial Window.</t>
        
        <t>The following examples provide some alternative examples of
        how to implement the Safe Retreat Phase:
        <list style="numbers">
             
            <t>A simple conservative approach sets CWND = IW and then
            resumes using normal slow-start.
            This method does not require measuring the capacity at congestion.
            The resulting pattern of CWND growth resembles that which
            would have occurred had the method not been used.</t>
             
            <t>Performance can be improved by tracking the volume of
            successfully transmitted packets sent
             using the Unvalidated Phase (e.g., by recording the sequence number
             of the first packet sent in the phase.).
            This measured capacity is called the Pipe.
         The Pipe is not a safe measure of the current
            available share of the capacity whenever
            there was also a significant overshoot of the capacity,
             as indicated by excessive loss.
            Therefore, any method that increases CWND based on received acknowledgments
             ought to be scaled
            to accommodate the overshoot, because overshoot
            could have resulted in unduly taking capacity from sharing flows.</t>
            <!--Methods using a slow-start threshold need to update this
            threshold using the Pipe, when this is known, on exit of the Safe Retreat Phase
            (i.e., ssthresh = Pipe).-->
          
      </list></t> <!--- End of list of examples -->

    </section><!-- End of Safety Requirements for the Safe Retreat Phase -->

    <section anchor="req-normal" title="Returning to Normal Congestion Control">
        <t>After using the method, the CC controller returns to the Normal Phase.

        <list style="symbols">
            <t>For NewReno and CUBIC, it is recommended to exit slow-start
            and enter the congestion avoidance phase.</t>

            <t>For BBR CC, it is recommended to enter the "probe bandwidth"
            state.</t>
        </list></t>
        <t>{XXX-Editor note: A future revision should discuss updating
        the saved values, whether used or not, after reaching normal operation for use
        the next time even if that update is to just refresh the expiration time.}</t>
    </section><!-- End of Normal Phase -->
    <section anchor="flow-control" title="Limitations from Transport Protocols">

        <t>A sender is limited by any rate-limitation of the transport
        protocol that is used.</t>

         <t> The implementation details for different transports depend on the
         deisgn of the transport.</t>

        <t>For QUIC this includes flow control mechanisms or preventing amplification
        attack. In particular, a QUIC receiver might need to issue proactive
        MAX_DATA frames to increase the flow control limits of a connection
        that is started with this method to gain the expected benefit.</t>

        <t>A TCP sender is limited by the receiver window (rwnd).
        Unless configured at a receiver, the rwnd can constrain the rate
        of increase for a connection and reduce the expected benefit of the method.</t>

    </section>     <!-- End of flow control, etc -->


</section> <!--  End of Guidelines -->

<section anchor="sec-acknowledgments" title="Acknowledgments">
      <t>The authors would like to thank John Border, Gabriel Montenegro, Patrick McManus,
      Ian Swett, Igor Lubashev, Robin Marx, Roland Bless, Franklin Simo, Raffaello Secchi for
      their fruitful comments on earlier versions of this document.</t>
      <t>The authors would like to particularly thank Tom Jones for co-authoring
      several previous versions of this document.</t>
    </section>

    <section anchor="sec-IANA" title="IANA Considerations">
      <t>No current parameters are required to be registered by IANA.</t>
    </section>

    <section anchor="sec-security" title="Security Considerations">
        <t>This document does not exhibit specific security considerations.
    Security considerations for the
    interactions with the receiver are discussed in <xref
        target="I-D.kuhn-quic-bdpframe-extension"></xref>.</t>
    </section> <!-- Sec Considerations -->
        
</middle>

  <!--  BACK MATTER -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
(for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
Both are cited textually in the same manner: by using xref elements.
If you use the PI option, xml2rfc will, by default, try to find included files in the same
directory as the including file. You can also define the XML_LIBRARY environment variable
with a value containing a set of directories to search.  These can be either in the local
filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
    
      <?rfc include="reference.RFC.2119.xml"?>

      <!-- <?rfc include="reference.RFC.6349.xml"?> -->

      <?rfc include="reference.RFC.8085.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>

      <?rfc include="reference.RFC.8801.xml"?>

      <?rfc include="reference.RFC.9000.xml"?>

      <!-- <?rfc include="reference.RFC.9001.xml"?> -->

    </references>

    <references title="Informative References">
          <?rfc include="reference.I-D.irtf-iccrg-sallantin-initial-spreading.xml"?>
          <?rfc include="reference.I-D.hughes-restart.xml"?>
    <?rfc include="reference.I-D.cardwell-iccrg-bbr-congestion-control.xml"?>
          <?rfc include="reference.I-D.kuhn-quic-bdpframe-extension.xml"?>
          <?rfc include="reference.RFC.3465.xml"?>
        <?rfc include="reference.RFC.4782.xml"?>
        <?rfc include="reference.RFC.5681.xml"?>
        <?rfc include="reference.RFC.5783.xml"?>
        <?rfc include="reference.RFC.6675.xml"?>
        <?rfc include="reference.RFC.6937.xml"?>
      <?rfc include="reference.RFC.8867.xml"?>
      <?rfc include="reference.RFC.9040.xml"?>
      <?rfc include="reference.RFC.9002.xml"?>


      <reference anchor="MAPRG111">
        <front>
          <title>Feedback from using QUIC's 0-RTT-BDP extension over SATCOM
          public access</title>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Stephan"></author>

          <author initials="G" surname="Fairhurst"></author>

          <author initials="T" surname="Jones"></author>

          <author initials="C" surname="Huitema"></author>

          <date year="2022" />
        </front>

        <seriesInfo name="IETF 111 - MAPRG meeting" value="" />
      </reference>

      <reference anchor="IJSCN">
        <front>
          <title>Google QUIC performance over a public SATCOM access</title>

          <author initials="L" surname="Thomas"></author>

          <author initials="E" surname="Dubois"></author>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Lochin"></author>

          <date year="2019" />
        </front>

        <seriesInfo name="International Journal of Satellite Communications and Networking"
                    value="10.1002/sat.1301" />
      </reference>

      <reference anchor="CONEXT15">
        <front>
          <title>Halfback: Running Short Flows Quickly and Safely</title>

          <author initials="Q" surname="Li"></author>

          <author initials="M" surname="Dong"></author>

          <author initials="P B" surname="Godfrey"></author>

          <date year="2015" />
        </front>

        <seriesInfo name="ACM CoNEXT" value="" />
      </reference>
    </references>

<section anchor="endpoint_token" title="Appendix: An Endpoint Token">

    <t>
    This annex proposes an Endpoint Token to allow a sender to identify its own
            view of the network path that it is using. In <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>
        this Endpoint Token could be shared and used as an
    opaque path identifier to other parties and the sender can verify if
    this is one of its current paths.
    </t>

    <section title="Creating an Endpoint Token">
        <t>
        When computing the Endpoint Token, the sender includes information to identify
        the path on which it sends, for example:
        <list style="symbols">
        <t>
            it needs to include a unique identifier for itself (e.g., a globally
            assigned address/prefix; or randomly chosen value).
        </t>
        <t>
            it needs to include an identifier for the destination (e.g., a
            destination IP address or name).
        </t>
        <t>
            it needs to include an interface identifier (e.g., an index value or a MAC address to associate the
            endpoint with the interface on which the path starts);
        </t>
        <t>
            it could include other information such as the DSCP, ports, flow
            label, etc (recognising that this additional information might improve the path
            differentiation, but that this can can reduce the re-usability of the
            token);
        </t>
        <t>
            it could include any other information the sender chooses to
        include, and potentially including PvD information <xref target="RFC8801"></xref> or
            information relating to its public-facing IP address;
        </t>
        <t>
            it could include a nonce;
        </t>
        <t>
            it could include a time-dependent value to define the validity
            period of the token.
        </t>
       </list></t>

        <t>
        When creating an Endpoint Token, the sender has to ensure the following:
        <list style="numbers">
        <t>
            To reduce the likelihood of misuse of the Endpoint Token, the value
            ought to be encoded in a way that hides the component information
        from the recipient and any eavesdropper on the path.
            </t>
        <t>
            The sender can recalculate the Endpoint Token if it needs to validate a
            previously issued token; and that the Endpoint Token itself can be
            included in the computed integrity check for any path
            information it provides.
        </t>
        <t>
            The Endpoint Token is designed so that if shared, it prevents another party from deriving
            private data from the token, or to use the token to perform
            unwanted likability with other information. This implies that
            the Endpoint Token MUST necessarily be different when used to identify
            paths using different interfaces.
            </t>
       </list> </t>
    </section>

 </section> <!-- End of An Endpoint Token -->
      
<section anchor="rev" title="Appendix: Revision details">
<t>Previous individual submissions were discussed in TSVWG and QUIC.
<list>
<t>WG -00 included clarifications and restructuring to form the 1st WG draft.</t>
<t>WG -01 included review comments and suggestions from John Border,
    and follows the setting of the TSVWG milestone
    with an intended status of "Proposed Standard".</t>
<t>WG -02 includes steps to complete the spec. In particular, consideration of application-limited
     senders; selection of reasoned parameters; specification of safe retreat; and
     improvements to the consistency throughout. Added the validating phase.</t>
</list></t>
</section> <!-- End of Revisions -->

</back>
</rfc>

