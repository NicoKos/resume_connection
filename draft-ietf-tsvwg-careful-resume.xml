<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="std" docName="draft-ietf-tsvwg-careful-resume-02"
     ipr="trust200902">
    <!-- category values: std, bcp, info, exp, and historic
    ipr values: full3667, noModification3667, noDerivatives3667
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
full title is longer than 39 characters -->

    <title abbrev="Careful Congestion Control Convergence">Careful Convergence of Congestion
    Control from Retained State</title>

    <author fullname="Nicolas Kuhn" initials="N" surname="Kuhn">
      <organization>Thales Alenia Space</organization>
      <address>
        <email>nicolas.kuhn.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Emile Stephan" initials="E" surname="Stephan">
      <organization>Orange</organization>
      <address>
        <email>emile.stephan@orange.com</email>
      </address>
    </author>

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>Department of Engineering</street>
          <street>Fraser Noble Building</street>
          <city>Aberdeen</city>
          <code>AB24 3UE</code>
          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Christian Huitema" initials="C" surname="Huitema">
      <organization>Private Octopus Inc.</organization>

      <address>
        <email>huitema@huitema.net</email>
      </address>
    </author>

    <date year="2023" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
in the current day for you. If only the current year is specified, xml2rfc will fill
in the current day and month for you. If the year is not the current one, it is
necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
purpose of calculating the expiry date).  With drafts it is normally sufficient to
specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
IETF is fine for individual submissions.
If this element is not present, the default is "Network Working Group",
which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>Transport, Congestion Control, QUIC</keyword>

    <!-- Keywords will be incorporated into HTML output
files in a meta tag but they have no effect on text or nroff
output. If you submit your draft to the RFC Editor, the
keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies a cautious method for IETF transports that
      enables fast startup of congestion control for a wide
      range of connections or reconnections.</t>
      <t>The method reuses a set of computed congestion control parameters that
      are based on previously observed path characteristics between
      the same pair of transport endpoints. These parameters
      are stored, allowing them to be later used to modify the congestion control behavior
      of a subsequent connection. The document discusses assumptions
      and defines requirements around how a
      sender utilizes these parameters to provide opportunities for a
      connection to more rapidly get up to speed (i.e. utilize the available
      capacity). It discusses how the method impacts the capacity at a
      shared network bottleneck and the safe response that is needed after any
      indication that the new rate is inappropriate.</t>
    </abstract>
  </front>

<middle>
<section anchor="sec:introduction" title="Introduction">
    <t>All Internet transports are required to either use a Congestion Control (CC) method, or
    to constrain their rate of transmission <xref target="RFC8085"></xref>. In 2010,
    a survey of alternative CC methods <xref target="RFC5783"></xref>, noted that there
    are challenges when a CC method operates across an Internet path with a high and/or
    variable bandwidth-delay product (BDP). This mechanism targets a
    solution for these challenges.</t>

    <t>A CC method typically takes time to ramp-up the packet rate,
    called the "slow-start phase", informally known as the time to "Get up
    to speed". This slow start phase defines a time in which a sender
    intentionally uses less capacity than might be available, with the
    intention to avoid or limit overshooting the available capacity at a bottleneck.
    The slow start design can increase queuing (latency/jitter) and/or
    congestion packet loss to the flow. Any overshoot in the capacity can have a
    detrimental effect on other flows sharing a common bottleneck. In the
    extreme case, persistent congestion could result in unwanted starvation of
    other flows <xref target="RFC8867"></xref> (i.e., Preventing other flows
    from successfully sharing a common bottleneck).</t>

    <t>The method is expected to reduce the time to complete a transfer
    when the transfer sends significantly more data than allowed by the
    Initial congestion window (IW), and
    where the BDP is also significantly
    more than the product of the IW and the  Round Trip Rime (RTT).</t>
    <t>It introduces an alternative method to select initial CC parameters,
    that seek to more rapidly and safely grow the congestion
    window (cwnd).
    This method is based on temporal sharing (sometimes known as
    caching) of a saved set of CC parameters that relate to previous observations
    of the same path. The saved CC parameters include:
    the bottleneck
    bandwidth, available capacity, and RTT. These
    parameters are stored and used to modify the CC
    behavior of a subsequent connection between the same local and remote endpoints.</t>

    <t>When used with the QUIC transport, this provides transport services that resemble
    those currently available in TCP, using methods such as TCP Control Block (TCB)
    <xref target="RFC9040"></xref> caching.</t>

    <section title="Use of saved CC parameters by a Sender">
        <t>CC parameters are used by this method for two functions:
        <list style="symbols">
            <t>Information to characterize the saved path that allow a sender to
            confirm whether the current path
            is consistent with a saved path.</t>
            <t>Information about the measured path capacity.
            This allows a later sender to
            determine an appropriate set of CC parameters for re-using the path.</t>
        </list></t>
           
            <t>"Generally, implementations are advised
            to be cautious when using previous values on a new path", as stated in <xref
                target="RFC9000"></xref>. This advice is appropriate for any IETF transport protocol.
            Care is therefore needed
            to assure safe use and to be robust to changes
            in traffic patterns, network routing and link/node conditions.
            There are cases where using the saved parameters of a previous
            connection are not appropriate.</t>
    </section>  <!-- End of use with care -->
          
    <section title="Receiver Preference">
            <t>Whilst a sender could take optimization decisions without considering
            the receiver's preference, there are cases where a receiver
            could have information that
            is not available at the sender, or might benefit from
         understanding that careful resume might be used. In these cases, a receiver
            could explicitly ask to enable or inhibit tuning of the CC
             when an application continues transmission.</t>
            
        <t>An indication from the sender that the method is available, could also
            allow a receiver to tune policies for using the connection (e.g., managing the
            receiver window or flow credit).</t>
           <t> Examples where a receiver could request not to use the method include:</t>
            <list style="numbers">
                <t>a receiver that can predict the pattern of traffic
                (e.g., insight into the volume of data to be sent,
                the expected length of a session, or the maximum transfer rate required);</t>
                <t>a receiver with a local indication that a path/local
                interface has changed since the CC parameters were stored;</t>
                <t>knoweledge of the current hardware limitations at a receiver;</t>
                <t>a receiver that can predit additional capacity will be needed
                for other concurrent/later flows
                (i.e., prefers to use the method for the other flows).</t>
            </list>

            <t>QUIC introduces the concept of transport parameters (Section 4 of
                <xref target="RFC9000"></xref>).
            A related document proposes an exchange for QUIC that requests
            the sender-generated CC parameters to be stored at the receiver
            <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>.
            Transferring the information to a receiver releases the need for a
            sender to retain transport state for each
            receiver. This document also evaluates the potential
            for malicious use of this exchange.</t>
    </section> <!-- End of Receiver Preference -->

    <section anchor="sec-use_case" title="Examples of Scenarios of Interest">

        <t> This section provides a set of examples where the method is expected to improve performance.</t>

        <t>Either endpoint can assume the role of a
        sender or a receiver. The method also supports a bidirectional data transfer,
        where both endpoints simultaneously send data (e.g., remote execution of an application, or a
        bidirectional video conference call).</t>

        <t>In one example, an application uses a series of connections over a path
        (i.e., resumes a connection to the same endpoint).
        Without this method,
        each connection would need to individually
        discover appropriate CC parameters, whereas the method allows the flow
        to continue at a rate that resembles the previous rate.</t>

        <t>In another example, an application reconnects after a disruption
        had temporarily reduced the path
        capacity (e.g., after a link propagation
        impairment, or where a user on a train journey travels through
        different areas of connectivity). When the endpoint
        returns to use a path with the original characteristics, it can resume
        a transmssion rate based on the previously measured characteristics.</t>

        <t>
        There is particular benefit for
        any path with an RTT that is much larger than for typical
        Internet paths.
        In a specific example, an application connected via a satellite access network
        <xref target="IJSCN"></xref>
        could require 9 seconds to complete a 5.3 MB transfer
        using standard CC, whereas using the
        method this transfer time could reduce to 4 seconds. The time to complete a 1 MB transfer could
        dimilarly reduce by 62 % <xref target="MAPRG111"></xref>. This benefit is also
        expected for other sizes of transfer and for different path
        characteristics when a path has a large BDP.</t>

        <t>{XXX-Editor note: A future revision would helpfully provide further Path Examples here.}</t>
    </section> <!-- Introduction: End of examples -->
   
</section> <!-- End of introduction and motivation -->

<!-- ****************************************************************************************** -->
<!-- The protocol spec follows below here, examples later -->

<section anchor="notation" title="Language, Notation and Terms">

    <t>This subsection provides a brief summary of key terms and the
    requirements language that is used.</t>

    <section anchor="sec:req_language" title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
         "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
         "OPTIONAL" in this document are to be interpreted as described in
         BCP 14
         <xref target="RFC2119"/>
         <xref target="RFC8174"/>
         when, and only when, they appear in all
         capitals, as shown here.</t>
    </section>

    <section anchor="sec-terms_def" title="Notation and Terms">
        <t> The document uses language drawn
        from a range of IETF RFCs.  It defines current, and saved values for a set of CC
        parameters:
        <list>

            <!-- GF (Feb 2023): Removed the IW from this information block??? -->
            <!-- it could potentially be in BDP but is not needed here -->
            <!--    <t>IW: Initial Window <xref target="RFC9002"></xref>;</t> -->
            <!--            <t>current_iw: Current IW;</t> -->
            <!--            <t>recom_iw: Recommended IW;</t> -->

            <t>current_bb : The currently estimated bottleneck bandwidth;</t>

            <t>saved_bb: The estimated bottleneck bandwidth preserved from a
            previous connection;</t>

            <t>current_rtt: The current RTT;</t>

            <t>saved_rtt: The measured RTT, preserved from a previous
            connection;</t>

            <t>endpoint_token: An Endpoint Token for a receiver;</t>

            <t>current_endpoint_token: The current Endpoint Token of the receiver;</t>

            <t>saved_endpoint_token: The Endpoint Token of a previous connection by the
            receiver;</t>

            <t>jump_cwnd: The resumed cwnd, used in the Unvalidated Phase.</t>
            <t>Pipe: The estimated capacity at the time of congestion.</t>
        </list>
        </t>

        <t>The Endpoint Token is described in <xref target="endpoint_token"></xref>.
        </t>

    </section> <!-- End of Notation: End of terms -->
</section><!-- End of Notation -->

<section anchor="sec-phase" title="The Phases of CC using Careful Resume">
    <t>This section defines a series of phases that the
    CC algorithm moves through as a connection
    uses the Careful Resume method.</t>

    <!-- These subsections to match next section format -->
      
    <section title="Observe Phase">
        <t>During a previous connection, information about the specific path
        to an endpoint is saved. This is used to characterize the path and
        to indicate the capacity that was available. This includes the current RTT
        (current_rtt), bottleneck bandwidth (current_bb) and a current receiver
        Endpoint Token (current_endpoint_token) stored as the saved_rtt, saved_bb and
        saved_endpoint_token. An implementation
        can store this information at the server (or could exchange this information
        with a receiver, as detailed in <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>).</t>
    </section> <!-- End of define "Observe Phase:"-->
          
    <section title="Reconnaissance Phase">
        <t> When a sender resumes transmission between the same pair of endpoints,
        (aka thinks it uses the same path) it enters the Reconnaissance Phase.
        The sender only enters this phase when there are saved CC parameters for the same
        pair of endpoints and this information is currently valid (i.e., the saved parameters have
        not expired.)
        When a method is provided (such as the BDP_Frame), a receiver can request
        the sender to not enter this phase.</t>

        <t>In this phase, the sender transmits initial data, limited by the Initial Window,
        and monitors its reception using received acknowledgements.
        This phase measures the current path characteristics
        and confirms these are consistent with the previously characterized path
        (including experiencing a similar RTT).

        <list style="symbols"> <!-- overview list of phase -->
            <t>Reconnaissance Phase: Endpoint change:
            If the current endpoint is not the same,
            the sender MUST revert to using the standard CC, and enters
            the Normal Phase. If the Endpoint Token changes
            (i.e., the saved_endpoint_token is different from the
            current_endpoint_token), it is assumed to represent a different network path.</t>

             <t>Reconnaissance Phase: RTT change: Since the CC information
             is directly impacted by the RTT, a significant change in the RTT
             is a strong indication that the previously estimated BDP
             parameters are not valid for the current path.</t>

            <t>Reconnaissance Phase: Lifetime of the information: The CC information is temporal.
            Frequent connections to the same endpoint are likely to track
            changes, but long-term use of previous values is not appropriate.</t>
        </list></t>

        <t>When a sender confirms the path characteristics
        (i.e., 0.5 *saved_rtt &gt; current_rtt &lt; 2.0 x saved_rtt) and it
        receives an acknowledgement for the initial data without reported congestion,
        it MAY then enter the Unvalidated Phase.
        This transition occurs when a sender has more data than permitted
        by the current cwnd.</t>

        <t>Implementation requirements are provided in <xref target="req-recon"></xref>.</t>

        <t>When the path is not confirmed, the method is not used
        and the sender returns to normal CC.</t>

    </section> <!-- End of define Reconnaissance Phase -->
    <section title="Unvalidated Phase">
        <t>This phase paces transmission using an increased rate/cwnd.
        A rate or jump_cwnd that is calculated based
        on the saved CC parameters:</t>
        <t><list style="symbols">
        <t>To avoid starving other (potential) flows that could have started
        or increased their capacity after the Observation Phase,
        the new rate MUST NOT utilise more than half of the previously used
        capacity, that is jump_cwnd &le; (saved_BDP/current_RTT).</t>
        <t>Transmission using an unvalidated cwnd/rate MUST use pacing.</t>
        <t>A sender monitors the correct reception
        of the packets that were sent using the unvalidated jump.
        If a sender determines either that the previous parameters
        are not valid (due to a detected change in the path)
        or that congestion was experienced,it enters the Safe Retreat Phase.</t>
        </list></t> <!-- End of list of actions -->

        <t>Implementation requirements are provided in <xref target="req-unvalid"></xref>. </t>
    </section> <!-- End of define Unvalidated Phase -->
          
    <section title="Safe Retreat Phase">

        <t>This phase is entered when a jump in the
        Unvalidated Phase has overshot the congested bottleneck capacity.
        It mitigates the impact on other flows :</t>
        
        <list style="symbols">
            <t>On entry, any saved CC parameters for
            this path are removed from any cache, to prevent these
            parameters being used again with other flows.</t>

            <t>The sender re-initializes the CC parameters to compensate for
            any overshoot in the Unvalidated Phase.
            This avoids starvation by helping other flows to regain
            their share of the available capacity:</t>

         <t>On entry, the cwnd MUST be initialised to
         no more than would have been
             used had the Careful Resume method not been used
            (i.e., cwnd &le; (2*IW)).</t>

            <t>The updated cwnd/rate MAY be further increased during recovery,
        when the sender receives acknowledgments indicating reception of packets that
        were sent during the Unvalidated Phase. Each acknowledged packet
        indicates a packet was successfuly traversed the path,
        and allows cwnd to be correspondingly increased.
        (An implementation could track this using a Pipe variable).</t>
            
        </list>
     
     <list><t>NOTE: The Safe Retreat reaction must differ from a traditional
        reaction to detected congestion, because
        the jump_cwnd can result in a significantly higher rate than would be allowed by the
        slow-start mechanism. This could aggressively feed a congested bottleneck,
        resulting in overshoot where a disproportionate number of packets
        from existing flows are displaced from
        the buffer at a congested bottleneck.
        For this reason, a sender needs to reduce its rate significantly
        below the measured capacity.</t></list>
          
        <t>Implementation requirements are provided in <xref target="req-retreat"></xref>.</t>

    <section title="Loss Recovery after entering Safe Retreat">

            <t>Unacknowledged packets that were sent in the Unvalidated Phase
            can be declared lost.
            Loss recovery commences using the reduced window
            that was set on entry to the Safe Retreat Phase.</t>

            <list><t>NOTE: A TCP or SCTP sender is always required to retransmit all lost data.
            For QUIC and DCCP, loss recovery
            depends on the sender policy for retransmission.</t></list>

            <list><t>NOTE: On entry to the Safe Retreat Phase the cwnd can be
            significantly reduced, in the case of multiple loss,
            recovery could require multiple RTTs to complete.</t></list>

            <t>On completion of any required recovery, the sender enters the Normal phase.</t>
    </section>     <!-- End of Safe Retreat Phase: loss recovery -->
    </section> <!-- End of define "Safe Retreat Phase" -->

          
    <section title="Normal Phase">
        <!-- We need to be careful here of the corner case that sender either did not
          utilise the jump, or the jump was not successful -->

        <t>In the Normal Phase, the sender transitions to using the normal CC method.</t>
        <list style="symbols">
            <t> The sender MUST reset cwnd
            on entry to the normal Phase to reflect the volume of
            acknowledged data that was received during the Unvalidated Phase.
            (When the sender has used the entire jump_cwnd and this was acknowledged
            in full, no adjustment is needed.)</t>
        </list>
        <t>Implementation requirements are provided in <xref target="req-normal"></xref>.</t>

    </section> <!-- End of define "Normal Phase:" -->
        
    <section title="RTO Expiry while using Careful Resume">
         <t>A sender that experiences a Retransmission Time Out (RTO) expiry
         while using Careful Resume, ceases to use the method, continuing using normal CC.</t>
    </section> <!-- End of define  ="RTO Expiry:" -->
</section>

<!-- ****************************************************************************************** -->
<!--- Here we provide guidance and requirements on implementation     -->
    
<section title="Congestion Control Guidelines and Requirements">

    <t>This section provides requirements for implementation and guidance on use.</t>

    <section anchor="flow-control" title="Limitations from Transport Protocols">

        <t>A sender is limited by any rate-limitation of the transport
        protocol that is used.</t>

        <t>For QUIC this includes: flow control mechanisms or preventing amplification
        attack. In particular, a QUIC receiver might need to issue proactive
        MAX_DATA frames to increase the flow control limits of a connection
        that is started with this method to gain the expected benefit.</t>

        <t>A TCP sender is limited by the receiver window (rwnd).
        Unless configured at a receiver, the rwnd can constrain the rate
        of increase for a connection and reduce the expected benefit of the method.</t>

    </section>     <!-- End of flow control, etc -->

    <section anchor="req-observe" title="Determining the current Path Capacity in the Observe Phase">
            
        <t>There are various approaches to measuring the capacity that have
        been used by a connection.
        Congestion controllers, such as CUBIC or RENO, can estimate the
        saved_bb and current_bb values by utilizing a combination of the
        cwnd/flight_size and the minimum RTT. A different approach could
        estimate the same values for a rate-based congestion
        controller, such as BBR <xref target="I-D.cardwell-iccrg-bbr-congestion-control"></xref>.
       
        <list style="symbols">
            <!-- Avoid unhelpful use of the method for small cwnds.-->
            <t>Observe Phase: If the cwnd is less than four times the IW
            (or the rate is less than would be permitted by IW*4/RTT),
            a sender SHOULD NOT store and/or send CC parameter
            information.</t>

            <t>Observe Phase: The sender SHOULD update the stored CC parameters and/or send updated CC parameter
            information related to an estimated bottleneck bandwidth
            (saved_bb).</t>
            <t>Observe Phase: The stored CC parameters SHOULD be updated \
            if there are significant changes in the CC parameters.
            The rate of update MUST be less than
            one update for several RTTs of time.</t>

            <t>Observe Phase: There are cases where the current cwnd/rate
            does not reflect the bottleneck bandwidth. At the End of the CC slow
            start phase, the value can be significantly larger than
            needed to fully utilize the path (i.e., a cwnd
            overshoot). It is inappropriate to use an
            overshoot in the cwnd as a basis for estimating the bottleneck
            bandwidth. In most case, the cwnd will converge to a stable
            value after several more RTTs.
            One mitigation could be to calculate the bottleneck
            bandwidth based on
            the flight_size or an averaged cwnd/rate. Also when
            is application-limited or in the final RTT following a burst of
            transmission, a sender typically transmits
            much less data than allowed. This case also ought to be discounted when
            estimating the bottleneck bandwidth.</t>
        </list></t>
        
    </section> <!-- Observe Phase  (measuring) -->

    <section anchor="req-recon"  title="Confirming the Path in the Reconnaissance Phase">
        <t>The sender initates a connection and starts sending initial data.
        It measures the RTT to confirm path it wishes to use.</t>

        <t> <list style="symbols">
            <t>Reconnaissance Phase: A sender MUST limit the initial data,
            sent in the first RTT of transmitted data,
            to not more than the IW <xref target="RFC9000"></xref>.</t>
        </list></t>

        <t> The transmission using the IW  is
        assumed a safe starting point for any path to avoid
        adding excessive load to a potentially congested path.
        any initial data. (When used in a controlled
        network, additional information about local path characteristics
        could be known, which might be used to configure a non-standard
        IW.)</t>

        <t>{XXX-Editor NOTE: A future revision of this document needs to specify how long
        CC Parameters can be cached, possibly based on TCP-new-CWV or TCB.}</t>

        <section anchor="sec-confirm" title="Confirming the Path">
             <t>Paths can change with respect to time for many reasons.
            This could result in previously measured CC parameters
            becoming irrelevant.</t>
        
            <t><list style="symbols">
                <t>The sender in the Reconnaissance Phase MUST compare the measured
                transport parameters (in particular current_rtt) of the new connection
                with the saved parameters (in particular, confirm the
                saved_rtt is consistent with the current RTT).
                The method MUST NOT be used when the path RTT fails to be
                confirmed.</t>
                
                <t>The sender MUST NOT use the parameters
                if any sent packet in the Reconnaissance Phase is detected as lost or
                acknowledgments indicate these packets were ECN CE-marked
                this MUST result in a transition to the Safe Retreat Phase. </t>
            </list></t>
        </section><!-- End of Reconnaissance:Confirming the Path -->
    </section> <!-- End of Reconnaissance(req-recon)  -->

    <section anchor="req-unvalid" title="Safety Requirements for the Unvalidated Phase">
            <t> This section defines the safety requirements
            for using saved CC parameters to tentaively update the cwnd.
            These safety guidelines mitigate the risk that sender
            adds excessive congestion to an already congested path.</t>

            <list style="symbols">
                <t>Unvalidated Phase: A new connection MUST NOT directly use the previously measured saved_rtt and
                saved_bb to simply initialize a new flow to resume sending at the same
                rate. The jump_cwnd MUST be no more than 1/2 the previous saved capacity based on the current RTT (saved BDP/ current RTT).</t>
            </list>
    
        <section title="Exit for the Unvalidated Phase because of Variable Network Conditions">
                <t>Unvalidated and Reconnaissance Phases: The method MUST be robust to
                network conditions that can differ from one connection to the next,
                due to variations in the forwarding path, reconfiguration of
                equipment, or changes in the link conditions.</t>
    
                <t><list style="symbols">
        
                    <t>Unvalidated Phase: The method MUST be robust to changes
                        in network traffic, including the
                     arrival of new traffic flows that compete for capacity at a shared bottleneck.</t>
                <t>Unvalidated Phase: The method MUST prevent unduly suppressing flows
                that used capacity since the available capacity was measured.</t>

                    <t>Unvalidated Phase: The sender MUST transition to the Safe Retreat Phase
                    when a packet loss is detected or acknowledgments indicate sent
                    packets were ECN CE-marked. These are an indication of potential
                    congestion.</t>
                </list></t>
        </section> <!--  Unvalidated Phase:  Network Conditions -->
            
        <section anchor="req-pace" title="Pacing in the Unvalidated Phase">
            
            <t> The sender MUST avoid sending a burst of packets greater than IW as a result of a
            step-increase in the congestion window <xref target="RFC8085"></xref>,
            <xref target="RFC9000"></xref>.
            Pacing sentpackets as a function of
            the current RTT can provide this additional safety during the
            Unvalidated Phase.
            Various other sender mitigatuons have also been suggested to
            avoid line-rate bursts (e.g., <xref target="I-D.hughes-restart"></xref>).</t>

            <t>The following example provides a relevant pacing rhythm:
            The sender estimates a pacing rhythm using saved_rtt and
            saved_bb. The Inter-packet Transmission Time (ITT) is determined
            from the ratio between the current Maximum Message Size (MMS) and
            the ratio between the saved_bb and saved_rtt. A tunable safety
            margin can avoid sending more than a recommended maximum
            (recom_jump):
            <list>
                <t>jump_cwnd = min(recom_jump,saved_bb/2)</t>
                <t>ITT = MSS/(jump_cwnd/saved_rtt)</t>
            </list></t>
            <t>This follows the idea presented in <xref target="RFC4782"></xref>,
            <xref target="I-D.irtf-iccrg-sallantin-initial-spreading"></xref> and
            <xref target="CONEXT15"></xref>.</t>
        </section> <!-- Unvalidated Phase: Pacing  -->
    </section> <!-- Unvalidated Phase -->

    <section anchor="req-retreat" title="Safety Requirements for the Safe Retreat Phase">
        <t>This section defines the safety requirements
        after congestion has been detected during the Unvalidated Phase.</t>

        <t>The following examples provide some alternative examples of
        how to implement the Safe Retreat Phase:</t>
        <list style="numbers">
            <t>A simple conservative approach sets cwnd = 2 x IW and then
            resumes using normal slow start.
            This method does not require measuring the capacity at congestion.
            Methods using a slow start threshold need to update this
            threshold using the cwnd
            (i.e.,  ssthresh = cwnd).
            The resulting pattern of cwnd growth resembles that which
            would have occurred had the method not been used.</t>
            <t>Performanance can be improved by tracking the volume of
            successfully transmitted packets during the RTT
            when using the Unvalidated Phase.
            This measured capacity under congestion is called the Pipe.
            Methods using a slow start threshold need to update this
            threshold using the Pipe
            (i.e.,  ssthresh = Pipe).
            The Pipe is not a safe measure of the current
            available share of the capacity whenever
            there was also a significant overshoot of the capacity,
         as indicated by excessive packet loss.
            Hence, the updated cwnd/rate must be further be reduced
            to reflect the size of the overshoot, because this
            which could have resulted in further loss to sharing flows
            (i.e., cwnd &lt;&lt; ssthresh).
            This ought to modify the update to cwnd: cwnd = (Pipe/2) x (Pipe/cwnd).</t>
        <t>{Editor-Note: This method is still to be confirmed. }</t>
          </list> <!--- End of list of examples -->

    </section><!-- End of Safety Requirements for the Safe Retreat Phase -->

    <section anchor="req-normal" title="Returning to Normal Congestion Control">
        <t>After using the method, the CC controller returns to the Normal Phase.

        <list style="symbols">
            <t>For NewReno and CUBIC, it is recommended to exit slow-start
            and enter the congestion avoidance phase.</t>

            <t>For BBR CC, it is recommended to enter the "probe bandwidth"
            state.</t>
        </list></t>
        <t>{XXX-Editor note: This should discuss updating
        the saved values, whether used or not, after reaching normal operation for use
        the next time even if that update is to just refresh the expiration time.}</t>
    </section><!-- End of Normal Phase -->
</section> <!--  End of Guidelines -->

<section anchor="sec-acknowledgments" title="Acknowledgments">
      <t>The authors would like to thank John Border, Gabriel Montenegro, Patrick McManus,
      Ian Swett, Igor Lubashev, Robin Marx, Roland Bless, Franklin Simo, Raffaello Secchi for
      their fruitful comments on earlier versions of this document.</t>
      <t>The authors would like to particularly thank Tom Jones for co-authoring
      previous versions of this document.</t>
    </section>

    <section anchor="sec-IANA" title="IANA Considerations">
      <t>No current parameters are required to be registered by IANA.</t>
    </section>

    <section anchor="sec-security" title="Security Considerations">
        <t>This document does not exhibit specific security considerations.
    Security considerations for the
    interactions with the receiver are discussed in <xref
        target="I-D.kuhn-quic-bdpframe-extension"></xref>.</t>
    </section> <!-- Sec Considerations -->
        
</middle>

  <!--  BACK MATTER -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
(for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
Both are cited textually in the same manner: by using xref elements.
If you use the PI option, xml2rfc will, by default, try to find included files in the same
directory as the including file. You can also define the XML_LIBRARY environment variable
with a value containing a set of directories to search.  These can be either in the local
filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
    
      <?rfc include="reference.RFC.2119.xml"?>

      <!-- <?rfc include="reference.RFC.6349.xml"?> -->

      <?rfc include="reference.RFC.8085.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>

      <?rfc include="reference.RFC.8801.xml"?>

      <?rfc include="reference.RFC.9000.xml"?>

      <!-- <?rfc include="reference.RFC.9001.xml"?> -->

    </references>

    <references title="Informative References">
          <?rfc include="reference.I-D.irtf-iccrg-sallantin-initial-spreading.xml"?>
          <?rfc include="reference.I-D.hughes-restart.xml"?>
    <?rfc include="reference.I-D.cardwell-iccrg-bbr-congestion-control.xml"?>
          <?rfc include="reference.I-D.kuhn-quic-bdpframe-extension.xml"?>
        <?rfc include="reference.RFC.4782.xml"?>

      <?rfc include="reference.RFC.5783.xml"?>
      <?rfc include="reference.RFC.8867.xml"?>
      <?rfc include="reference.RFC.9040.xml"?>

      <reference anchor="MAPRG111">
        <front>
          <title>Feedback from using QUIC's 0-RTT-BDP extension over SATCOM
          public access</title>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Stephan"></author>

          <author initials="G" surname="Fairhurst"></author>

          <author initials="T" surname="Jones"></author>

          <author initials="C" surname="Huitema"></author>

          <date year="2022" />
        </front>

        <seriesInfo name="IETF 111 - MAPRG meeting" value="" />
      </reference>

      <reference anchor="IJSCN">
        <front>
          <title>Google QUIC performance over a public SATCOM access</title>

          <author initials="L" surname="Thomas"></author>

          <author initials="E" surname="Dubois"></author>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Lochin"></author>

          <date year="2019" />
        </front>

        <seriesInfo name="International Journal of Satellite Communications and Networking"
                    value="10.1002/sat.1301" />
      </reference>

      <reference anchor="CONEXT15">
        <front>
          <title>Halfback: Running Short Flows Quickly and Safely</title>

          <author initials="Q" surname="Li"></author>

          <author initials="M" surname="Dong"></author>

          <author initials="P B" surname="Godfrey"></author>

          <date year="2015" />
        </front>

        <seriesInfo name="ACM CoNEXT" value="" />
      </reference>
    </references>

<section anchor="endpoint_token" title="Appendix: An Endpoint Token">

    <t>
    This annex proposes an Endpoint Token to allow a sender to identify its own
            view of the network path that it is using. In <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>
        this Endpoint Token could be shared and used as an
    opaque path identifier to other parties and the sender can verify if
    this is one of its current paths.
    </t>

    <section title="Creating an Endpoint Token">
        <t>
        When computing the Endpoint Token, the sender includes information to identify
        the path on which it sends, for example:
        <list style="symbols">
        <t>
            it needs to include a unique identifier for itself (e.g., a globally
            assigned address/prefix; or randomly chosen value).
        </t>
        <t>
            it needs to include an identifier for the destination (e.g., a
            destination IP address or name).
        </t>
        <t>
            it needs to include an interface identifier (e.g., an index value or a MAC address to associate the
            endpoint with the interface on which the path starts);
        </t>
        <t>
            it could include other information such as the DSCP, ports, flow
            label, etc (recognising that this additional information might improve the path
            differentiation, but that this can can reduce the re-usability of the
            token);
        </t>
        <t>
            it could include any other information the sender chooses to
        include, and potentially including PvD information <xref target="RFC8801"></xref> or
            information relating to its public-facing IP address;
        </t>
        <t>
            it could include a nonce;
        </t>
        <t>
            it could include a time-dependent value to define the validity
            period of the token.
        </t>
       </list></t>

        <t>
        When creating an Endpoint Token, the sender has to ensure the following:
        <list style="numbers">
        <t>
            To reduce the likelihood of misuse of the Endpoint Token, the value
            ought to be encoded in a way that hides the component information
        from the recipient and any eavesdropper on the path.
            </t>
        <t>
            The sender can recalculate the Endpoint Token if it needs to validate a
            previously issued token; and that the Endpoint Token itself can be
            included in the computed integrity check for any path
            information it provides.
        </t>
        <t>
            The Endpoint Token is designed so that if shared, it prevents another party from deriving
            private data from the token, or to use the token to perform
            unwanted likability with other information. This implies that
            the Endpoint Token MUST necessarily be different when used to identify
            paths using different interfaces.
            </t>
       </list> </t>
    </section>

 </section> <!-- End of An Endpoint Token -->
      
<section anchor="rev" title="Appendix: Revision details">
<t>Previous individual submissions were discussed in TSVWG and QUIC.</t>
<list>
<t>WG -00 included clarifications and restructuring to form the 1st WG draft.</t>
<t>WG -01 included review comments and suggestions from John Border,
    and follows the setting of the TSVWG milestone
    with an intended status of "Proposed Standard".</t>
</list>
</section> <!-- End of Revisions -->

</back>
</rfc>

