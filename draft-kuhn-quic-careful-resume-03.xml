<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="info" docName="draft-kuhn-quic-careful-resume-03"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
ipr values: full3667, noModification3667, noDerivatives3667
you can add the attributes updates="NNNN" and obsoletes="NNNN"
they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
full title is longer than 39 characters -->

    <title abbrev="Careful convergence of congestion control">Careful convergence of congestion 
    control from retained state with QUIC</title>

    <author fullname="Nicolas Kuhn" initials="N" surname="Kuhn">
      <organization>Thales Alenia Space</organization>

      <address>
        <email>nicolas.kuhn.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Emile Stephan" initials="E" surname="Stephan">
      <organization>Orange</organization>

      <address>
        <email>emile.stephan@orange.com</email>
      </address>
    </author>

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>Department of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <code>AB24 3UE</code>

          <country>Scotland, UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Christian Huitema" initials="C" surname="Huitema">
      <organization>Private Octopus Inc.</organization>

      <address>
        <email>huitema@huitema.net</email>
      </address>
    </author>

    <date year="2023" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
in the current day for you. If only the current year is specified, xml2rfc will fill
in the current day and month for you. If the year is not the current one, it is
necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
purpose of calculating the expiry date).  With drafts it is normally sufficient to
specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
IETF is fine for individual submissions.
If this element is not present, the default is "Network Working Group",
which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>QUIC, convergence</keyword>

    <!-- Keywords will be incorporated into HTML output
files in a meta tag but they have no effect on text or nroff
output. If you submit your draft to the RFC Editor, the
keywords will be used for the search engine. -->

    <abstract>
      <t>This document discusses careful convergence of congestion
      control in QUIC, providing
      a cautious method that enables fast startup in a wide
      range of connections : 0-RTT, new connections sharing the same
      peers (but not using 0-RTT (but not using 0-RTT)), application-limited traffic.</t>

      <!-- start new from v2 to v3 -->
      <t>The method provides QUIC with transport services that resemble 
	those     
      currently available in TCP, such as TCP Control Block (TCB) caching or
      updates to support application-limited traffic.</t>
      <!-- end new from v2 to v3 -->

      <t>The method uses a set of computed Congestion Control (CC) parameters that
      are based on the previously observed path characteristics between the
	the same pair of transport endpoints, such as the
      bottleneck bandwidth, available capacity, or the RTT. These parameters
      are stored, allowing then to be later used to modify the congestion control behavior
      of a subsequent connection. The document discusses assumptions/requirements around how a
      sender ought to utilize these parameters to provide opportunities for a
      new connection to more quickly get up to speed (i.e. utilize the available
      capacity). It discusses how these changes impact the capacity at a
      shared network bottleneck and the response that is needed after any
      indication that the new rate is inappropriate.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="sec:introduction" title="Introduction">
      
	<t>All Internet transports are required to use a CC method. In 2010, 
	<xref target="RFC5783"></xref> provided a survey of alternative CC methods, and noted that there
	are challenges when a CC operates across an Internet path with a high and/or
	variable bandwidth-delay product (BDP).</t>
      
      	<t>A CC algorithm typically takes time to ramp-up the packet rate,
      	called the "slow-start phase", informally known as the time to "Get up
      	to speed". The slow start phase is a period in which a sender
      	intentionally uses less capacity than might be available with the
      	intention to avoid overshooting the actual capacity at a bottleneck.
      	This would result in increased queuing (latency/jitter) and/or
      	congestion packet loss to the dlow. Any overshoot in the capacity can also have a
      	detrimental effect on other flows sharing a common bottleneck. In the
      	extreme case, persistent congestion can result in unwanted starvation of
      	other flows <xref target="RFC8867"></xref> (i.e. Preventing other flows
      	from successfully sharing a common bottleneck).</t>

      	<!-- Omitted  ****************************
      	<t>In <xref target="RFC6582">Reno</xref> , the slow-start phase consists of a sequence of increases in
      	the congestion window (cwnd) starting from the Initial Window (IW). Each
      	step lasts approximately one path RTT, until the sender estimates that
      	the capacity at the bottleneck
      	for the path has been (or is nearing) reached.</t>

      	<t>To fully-utilize the capacity along a path with an RTT,
      	the transport needs to determine an appropriate volume of bytes in
      	flight, based on the product of the available capacity and the path RTT.
      	<xref target="RFC6349"></xref> defines the bandwidth-delay product as follows: "Derived from
      	Round-Trip Time (RTT) and network Bottleneck Bandwidth (BB), the
      	Bandwidth-Delay Product (BDP) determines the Send and Received Socket
      	buffer sizes required to achieve the maximum TCP Throughput." The BDP
      	estimated by a sender includes all buffering experienced along a network
	path. Various approaches are possible to determine the BDP, based on
      	measurements of the path characteristics. <xref target="RFC6349"></xref>
      	specifies one procedure for TCP. CC for QUIC is specified in <xref
      	target="RFC9002"></xref> and does not specify a required method to
      	measure the BDP, allowing the sender to implement an appropriate
      	method.</t>
         -->
      <!-- end of Omitted Text **************************** -->

      <t>This document specifies a method that can improve throughput by 
      reducing the time to get up to speed, and hence reduce the
      total duration of a transfer. It
      introduces an alternative method to select initial CC parameters,
      including a way to more rapidly and safely grow the cwnd.</t>
      
      <t>The method provides performance benefits
      	for QUIC transport services that resemble
      	methods currently available in TCP.
      	Performance benefits can arise from sharing transport information 
      	about a previously used path across
      	multiple concurrent connections, and also across sequential
	connections to the same receiver.
	TCP Control Block (TCB) <xref target="RFC9040"></xref>
        describes the sharing of transport parameters between TCP connections. 
	The method in this document also builds on performance improvement to TCP 
	that are designed to
	support application-limited traffic <xref target="RFC7661"></xref>.</t>
	
	<t>Cases where temporal sharing of previously parameters
      	relating to observed path characteristics
      	can help to save round-trip times at the start of a new connection include:
	<list style="numbers">
          		<t>To optimize applications that use a series of short connections over the
          		same path, each of which needs to individually learn the available
	  		capacity/rtt;</t>

          		<t>After a pause in transmission (e.g., when transmission
          		pauses, and then the transport protocol wishes to connect over the
          		same path);</t>

          		<t>To connect after a service disruption where the
          		network service was temporarily reduced (e.g., due to a link propagation
          		impairment, or where a user on a train journey travels through
          		different areas of connectivity before the user returns to a path with the original
          		characteristics).</t>
	</list></t>

        <Section title="Using the Information with Care">
      		<t>The specification for the QUIC transport protocol <xref
      		target="RFC9000"></xref> notes "Generally, implementations are advised
      		to be cautious when using previous values on a new path." The method
      		uses a set of computed CC parameters that are based
      		on the previously observed path characteristics, such as the bottleneck
      		bandwidth or available capacity, and the RTT. These
      		parameters are stored and can then used to modify the CC
      		behavior of a subsequent connection. </t>
      	</section>  <!--- end of use with care --> 
          
	<section title="Receiver Preference">

      	        <t>While a sender could make optimization decisions without considering 
      	        the receiver's preference, in some cases a receiver could have information that 
      	        is not available at the sender, which could be used to
		inhibit optimization. This could be useful when:
      	       <list>
      			<t>A receiver discovers the path has changed, 
			e.g., from an indication that the local interface has changed;</t>
			<t>A receiver has information related to current hardware limitations of the receiver;</t>
		        <t>A receiver has an understanding about
      			the capacity needs of other concurrent flows that would compete for 
      			shared capacity. As a result, a receiver could explicitly ask for tuning the 
      			slow start when the application continues transmission.</t>
      	       </list>
	   	<t>       
		A related document complements this CC method by allowing storage
      	    	of the sender-generated transport information at the receiver. This avoids
		requiring the sender to retain additional state for each
		receiver. This
      	    	also enables a receiver to implement a policy to inform a sender
      	    	whether it desires to reuse the transport information.</t>
	</section> <!--- end of Receiver Preference -->

	<section anchor="sec-use_case" title="Examples of Scenarios of Interest">
    
    		<t> This secion provides a set of examples where the method is expected to improve performance.</t>

        	<t>QUIC introduces the concept of transport parameters (section 4 of
        	<xref target="RFC9000"></xref>). This document notes that a new
        	connection can utilize a set of key transport parameters from a
        	previous connection to reduce the completion time for a transfer 
		where the transfer
       		is significantly larger than the IW, and the BDP is also significantly 
		more than the IW. This benefit is particularly
        	evident for a path where the RTT is much larger than for typical
        	Internet paths.</t>
		
		<t>The method can be used by a sender performing a unidirectional data transfer
        	towards the receiver, (e.g., a receiver downloading a file or a web page). This
        	is the focus of the current version of the document.</t>

        	<t>Receivers can also perform a bidirectional data transfer,
		where both endpoints simulatenouysly send data to
       		each other (e.g.,  remote executing application, or a
        	video conference call).</t>

        	<t>In general, the method in this document applies to a
        	CC that sends data to a remote endpoint and that remote
        	endpoint resumes the connection. Both endpoints can assume the role of a
        	sender or a receiver.</t>

	    <section title="A Satellite Access Network Example"> 

        	<t>For example, a satellite access network, a 5.3 MB transfer takes up
        	to 9 seconds using standard congestion control, whereas using the
        	specified method this could reduce to 4 seconds <xref
        	target="IJSCN"></xref>; and the time to complete a 1 MB transfer could
        	be reduced by 62 % <xref target="MAPRG111"></xref>. Benefit is also
        	expected for other sizes of transfer and for different path
        	characteristics that also result in a high BDP.</t>
	    </section> <!-- End of intro:examples:satcom -->
	    
<!--- GF: BDP: THIS TEXT SEEMS RELATED TO THE BDP FRAME NOT THE CAREFUL RESUME
  section title="Saving Path Information"	

	<t> Three approaches are compared:  
	<list>
	<t>(1) The saved information is stored at the sender 
        ("Local storage") and is never sent to a receiver;</t>
	<t>(2) Some information is transmitted to the receiver,
        which can be used when reconnecting, but the receiver cannot read the
        information received from the sender ("NEW TOKEN");</t>
	<t>(3) the
        saved information is
        transmitted to a receiver, which can use it when reconnecting.
        The receiver can read it to accept or not the exploitation of
        previous congestion information (a.k.a. "BDP extension").
	</list>
	</t>
  /section
 --->

<!--- GF: BDP: This is argument for the BDP Frame, not careful resume ---

          <t>In some cases, the receiver could be aware of a change in the path
          (e.g., a change in the local interface), and might be
          able to determine that the current path is different.</t>
	  
          <t>In other cases, a receiver could discover
          that a previously characterised path has again become
          available providing an opportunity to reduce the time to get up 
          to speed by utilizing saved CC information for this path.</t>
	
          <t>To safely utilize this information, the receiver
          would need assurance that this path was to the same endpoint, and that
          the characteristics have not significantly changed from those
          previously measured.</t>
	  
--->

<!-- GF: Note we agreed to not specifically comment on DASH -->
<!--- If retained, this section on the client behaviour belongs in the BDP-Frame
    
    section anchor="subsec:rationale_client" title="Optimizing Client Requests"
	<t>Where the receiver is aware of a high BDP, it can adapt other parameters
	to better utilize the available capacity, such as 
	increasing the value of flow control pararemeters.</t>

        <t>Some designs of application do not use long-lasting transport connections. 
        Instead, they use a series of shorter connections, typically
	each using the same path. This style of application can benefit 
	from this method, and could be enhanced by allowing the application
	to receive an estimate of the expected characteristics, which could help
	to appropriately use the new connection (e.g.,
	adapting the content of quality for a video application; or anticipating
	the time taken to complete the transmission of an object). </t>
	
	<t> For example, a client using Dynamic Adaptive Streaming over HTTPS
        (DASH). Such a client might be unable to receive sufficient data
	to reach the video playback
        quality that is supported by the path, because for each video chunk,
        the transport protocol needs to independently determine the path
        capacity. The lower transfer rate is safe, but can also lead to an
        overly conservative requested rate to the sender, because clients
        often adapt their application-layer requests based on the transport
        performance (i.e., the client could fail to increase the requested
        quality of video chunks, or to fill buffers to avoid stalling playback
        or to send high quality advertisements). </t>
	      
        <t> When using Dynamic Adaptive Streaming over HTTPS (DASH), clients
	might encounter issues in knowing the available path capacity or DASH
	can encounter issues in reaching the best available video playback
	quality.  The client requests could then be adapted and specific
	traffic could utilize the previously observed path characteristics (such
	as encouraging the client to increase the quality of video chunks, to
	fill the buffers and avoid video blocking or to send high quality
	adds).</t>
      /section>
      --->
<!--- ************************************ --->

    </section <!--- end of examples -->

    <section title = "Structure of this Document">
      <t>The remainder of this document: <list style="numbers">
          <t>discusses use-cases where a careful resume for a QUIC connection is
          expected to have benefit;</t>

          <t>proposes guidelines for how to carefully utilize the previously
          stored CC information;</t>

          <t>describes implementation considerations for the proposed method
          using QUIC;</t>

          <t>discusses the trade-offs associated with the different
          implementation solutions.</t>
        </list></t>
    </section> <!-- End of stucture at end of intro-->
    
</section> <!-- end of introduction and motivation -->
    
 <!--- The protocol spec follows below here -->

<section anchor="notation" title="Language, notations and terms">

      <t>This section provides a brief summary of key terms and the
      requirements language that is used. The document uses language drawn
      from a range of IETF RFCs. </t>

    <section anchor="sec:req_language" title="Requirements Language">
        <t>The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in BCP
        14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when,
        and only when, they appear in all capitals, as shown here.</t>
    </section>

    <section title= "Sender-generated information information">
	<t>Sender-generated information information is used for two functions:
		<list>
			<t>Information about the capacity available on a saved path, to allow a sender to
			determine an appropriate set of CC paramaters for the current path.</t>
			<t>Information to charactise the saved path, to allow a sender to
			establish if the saved information is consistent with the
			current path.</t>
		</list>
	</t>
    </section> <!--- End of Notation: the information -->

    <section anchor="sec-terms_def" title="Notations and Terms">
        <t>This document defines current, and saved values for a set of CC
        parameters:
	<list style="symbols">

<!--- GF: Why is IW in this information block??? it could potentially be in BDP but is not needed here --->
<!---	<t>IW: Initial Window <xref target="RFC9002"></xref>;</t> --->
<!---            <t>current_iw: Current IW;</t> --->
<!---            <t>recom_iw: Recommended IW;</t> --->

            <t>current_bb : Current estimated bottleneck bandwidth;</t>

            <t>saved_bb: Estimated bottleneck bandwidth preserved from a
            previous connection;</t>

            <t>current_rtt: Current RTT;</t>

            <t>saved_rtt: RTT measure RTT preserved from a previous
            connection;</t>

            <t>endpoint_token : Endpoint Token of the receiver;</t>

            <t>current_endpoint_token : Current Endpoint Token of the receiver;</t>

            <t>saved_endpoint_token : Endpoint Token of a previous connection by the
            receiver;</t>

            <t>remembered BDP parameters: a combination of saved_rtt and
            saved_bb</t>
          </list>
	</t>

        <t>The Endpoint Token is described in <xref target="endpoint_token"></xref>.
	</t>

        <t>Congestion controllers, such as CUBIC or RENO, could estimate the
        saved_bb and current_bb values by utilizing a combination of the
        cwnd/flight_size and the minimum RTT. A different method could be used
        to estimate the same values when using a rate-based congestion
        controller, such as BBR <xref target="I-D.cardwell-iccrg-bbr-congestion-control"></xref>.</t>
      </section> <!--- End of Notation: end of terms --->
</section><!--- End of Notation -->

<section anchor="sec-phase" title="The Phases of CC">
      <t>This section defines a series of phases through which the
      CC algorithm moves as a connection gets up to speed. 
      
      <list style="numbers">
      
          <t>Observe: During a previous connection, information about the path
	  to an endpoint is saved. This is used to characterise the path and
	  to indicate the capacity available. It includes the current RTT
          (current_rtt), bottleneck bandwidth (current_bb) and current receiver
          Endpoint Token (current_endpoint_token) are stored as saved_rtt, saved_bb and
          saved_endpoint_token.</t>

          <t>Reconnaissance: When a sender resumes between the same pair of endpoints, 
	  it enters the Reconnaissance Phase.
	  This 
	  phase is designed to check the current path is consistent with saved path information
	  and also to avoid resuming under severely congested conditions.
	  The sender only enters this phase when there is saved infromation for the same
	  pair of endpoints and the information is valid (i.e., the infromation has
	  not expired.)
	  If a method is provided (such as the BDP_Frame), the receiver can request
	  the sender to not enter this phase.
          The sender measures the path characteristics of the present
          path to confirm that the path is similar to that previously characterised
          (including a similar RTT). The sender is allowed to send iniial data
	  limited by the Initial Window.
	  <list>
	  	<t>If the sender determines either that the path RTT and other saved path information
	 	 are not consistent with the current path or that any sent initial data 
	  	was not correctly received, then the sender continues using the standard CC, and enters 
		the Normal Phase.</t>
	 	<t>If the sender confirms both that the saved and current path information are consistent 
		and that the sent initial data 
	  	was correctly received, the sender enters the Unvalidated Phase.</t>
	  </list>
	  </t>
	  
          <t>Unvalidated: In the Unvalidated Phase, a sender can
	  utilize the saved path information to update its CC parameters. This phase enables a
          rate higher than allowed by a traditional
          slow-start mechanism. The convergence towards the
          previous rate is expected to be faster, but should not be instantaneous, to avoid
          adding congestion to an already congested bottleneck. In this phase, the sender
	  continues to check the saved and current path information are consistent. 
	  <list style="numbers">
              <t>If a sender determines either that previous parameters
              are not valid (due to a detected change) or congestion was experienced,
              then the sender must rapidly retreat to a safe rate.</t>
	       <t>If the unvalidated rate is used without inducing significant
              congestion to the path, then the sender is permitted to continue
              at this rate in the 'Normal' phase.</t>
            </list></t>

          <t>Retreat: In the Retreat Phase, the sender stops using the saved path 
	  characteristics. This phase is designed to mitigate the impact on other
	  flows that might have been sharing a congested bottleneck. 
	  The sender needs to re-initialised CC parameters to drain any queue built
	  at the bottleneck duing the Unvalidated Phase and allow other flows to regain
	  their share of the available capacity. This reaction differs to the traditional
	  congestion control reaction, because the sender CC was unvalidated.
	  Saved path information should be removed, to prevent it being used with other
	  flows.
	  <list style="numbers">
              <t>The sender then enters the 'Normal' phase with the re-initialised CC parameters.</t>
          </list></t>

          <t>Normal: The sender resumes using the normal CC method.</t>
        </list></t>
	
    </section> <!-- End of Phases -->

    <section anchor="sec-rationale" title="Safety Guidelines">
	<t> This section introduces the rationale behind safety guidelines
        for the usage of saved infromation: variable
	network conditions and malicious receviver.</t>
	
	<section  title="Internet Paths">
	<t>Paths and capacity can change with respect to time, resulting
	in "variable network
        conditions". This can result in previously measured values
        becoming irelevant and requires careful use by a
        CC algorithm.</t>
	
	<t>EDITOR NOTE: The sender ought not to re-utilize all the capacity it previously
        used, to avoid starving other flows that started or increased their capacity after the last measurement.
        How strong should this be stated: ... MUST or SHOULD ... What safety
        factor is appropriate for the resuming sender? If using slow-start it
        would anyway double the rate on the next RTT, so is capacity/2
        appropriate to initially try?</t>

        <t>A new connection MUST NOT use the previously measured saved_rtt and
        saved_bb to simply initialize a new flow to resume sending at the same
        rate.</t>

        <t> Bottleneck bandwidth and network traffic can
            change at any time. An Internet method needs to be robust to
            network conditions that can differ from one connection to the next,
            due to variations in the forwarding path, reconfiguration of
            equipment or changes in the link conditions.</t>
	 <t>The method
            needs to be robust to changes in network traffic, including the
            arrival of new traffic flows that compete for the bottleneck
            capacity. Behaviors need to be designed that avoid sending
            excessive data into a congestion bottleneck because this can have
            a material impact on any flows using that bottleneck, and the
            ability of those flows to control their own sending rate.</t>
      </section> <!-- End of Safety: Internet Paths --->

      <section title="Variable Network Conditions">
        <t>The sender MUST check the validity of any received saved_rtt and
        saved_bb parameters, whether these are sent by a receiver or are stored
        at the sender. The following events indicates cases where the use of
        these parameters is inappropriate: 
	<list style="symbols">
            <t>Endpoint Token change: If the Endpoint Token changes 
            (i.e., the saved_endpoint_token is different from the
            current_endpoint_token), the different Endpoint Token can be assumed as an
            indication of a different network path. This new path does not
	    necessarily exhibit the same characteristics as the old one.</t>

            <t>RTT change: A significant change in RTT might be an indication
            that the network conditions have changed. Since the CC information
            is directly impacted by the RTT, a significant change in the RTT
            is a strong indication that the previously estimated BDP
            parameters are likely to not be valid for the current path. NOTE:
            This document needs to define a significant change.</t>

            <t>Lifetime of the information: The CC information is temporal.
            Frequent connections to the same Endpoint Token are likely to track
            changes, but long-term use of previous values is not appropriate.
            NOTE: This document needs to define how long.</t>
		
            <t>BB over-estimation: There are cases where using a measured cwnd
            would inflate the bottleneck bandwidth. At the end of the CC slow
            start phase, the value of cwnd can be significantly larger than
            the minimum value needed to utilize the path (i.e., cwnd
            overshoot). In most case, the cwnd finally converges to a stable
            value after several more RTTs. It would be inappropriate to use an
            overshoot in the cwnd as a basis for estimating the bottleneck
            bandwidth. NOTE: One mitigation could be to further restrict to
            only a fraction (e.g., 1/2) of the previously used cwnd; another
            mitigation might be to calculate the bottleneck bandwidth based on
            the flight_size or an averaged cwnd.</t>

            <t>Preventing Starvation of New Flows: It would not be appropriate
            to fully use a bottleneck bandwidth estimate based on a previous
            measurement of capacity, because new flows might have started
            using the available capacity since that measurement was made. The
            mitigation could be to restrict to only a fraction (e.g., 1/2) of
            the previously used cwnd.</t>
          </list></t>

	<t>{XXX-Editor note: Decide on mittigation.}</t>
        <t>The impact of changes can be mitigated by 2 potential solutions: 
	<list style="symbols">
            <t> When resuming, restore
            the current_bb and current_rtt from the saved_bb and saved_rtt
            parameters estimated from a previous connection.</t>

            <t>When resuming, implement
            a safety check to measure and avoid using the saved_bb and saved_rtt
            parameters to cause congestion over the path. In this case, the
            current_bb and current_rtt might not be set directly from the
            saved_bb and saved_rtt: the sender might wait for the completion
            of the safety check before this is done.</t>
          </list></t>
      </section> <!-- End of Safety: Network Conditions --->

<!--- BDP Frame -->
      <section title="Protecting from Malicious Receivers">
        <t>The sender MUST check the integrity of the saved_rtt and saved_bb
        parameters received from a receiver.</t>

        <t>There are several solutions to avoid attacks by malicious receivers:
        <list style="symbols">
            <t>Solution #1 : The sender stores a local estimate
            of the bottleneck bandwidth and RTT parameters as the saved_bb and
            saved_rtt.</t>

            <t>Solution #2 : The sender sends the estimate of
            the bottleneck bandwidth and RTT parameters to the receiver as the
            saved_bb and saved_rtt in a block of information that is
            authenticated. This information also could be encrypted by the
            sender. The receiver resends the same information for a new
            connection. The sender can use its local key information to
            authenticate the information, without needing to keep a local
            copy.</t>

            <t>Solution #3 : This approach is the same as
            above, except that the sender provides an estimate of the saved_rtt
            and saved_bb parameters in a form that may be read by the receiver.
            Using the security mechanisms provided in <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>,
            the sender can verify that the receiver did not change the parameters inside the frame.
	    The receiver can 
            read, but not modify, the saved_rtt and saved_bb parameters and
            could enable a receiver to decide whether the new
            parameters are thought appropriate, based on receiver-side information about
            the network conditions, connectivity, or needs of the new
            connection.</t>
          </list></t>

        <t><xref target="sec-implem"></xref> describes various implementation
        approaches for each of these solutions using local storage (
	<xref target="sec-local_storage"></xref> for Rationale #2 - Solution #1),
        NEW_TOKEN Frame ( <xref target="sec-using_new_token"></xref> for
        Rationale #2 - Solution #2), BDP extension Frame ( <xref
        target="sec-bdp_frame_section"></xref> for Rationale #2 - Solution
        #3).</t>
      </section> <!-- End of Safety: Malicous Clients --->

        <t>Security consideration are discussed in <xref
        target="sec-security"></xref> .</t>
	    </section>

 <!--- BDP Frame --->
	      
        <section title="Interoperability and Use Cases">
          <t>A sender that stores a resumption ticket for each receiver to
          protect against replay on a third party, it could also store the
          Endpoint Token (i.e., saved_endpoint_token) and BDP parameters (i.e.,
          saved_rtt and saved_bb) of a previous connection.</t>

          <t>When the BDP Frame extension is used, locally stored BDP
          parameters at the sender can provide a cross-check of the BDP
          parameters sent by a receiver. The sender can anyway enable a safe
          jump, but without the BDP Frame extension. However, using the
          parameters enables a receiver to choose whether to request this or
          not, enabling it to utilize local knowledge of the network
          conditions, connectivity, or connection requirements.</t>

          <t>{XXX-Editor-note: Text to be improved: Storing local values
          related to the BDP would help improve the ingress for new
          connections, however, not using a BDP Frame extension could reduce
          the interest of the approach where (1) the receiver knows the BDP
          estimation at the sender, (2) the receiver decides to accept or reject
          ingress optimization, (3) the receiver tunes application level
          requests.}</t>
        </section> <!-- End of Safety: Tradeoff: Use Cases --->
	</section> </section> <!-- End of Safety: Tradeoff --->

<section anchor="sec-safety_guide" title="CC Safety Guidelines">
      <t>The following safety guidelines refer to the labeling defined in
      <xref target="sec-phase"></xref>.</t>

      <t>These safety guidelines are designed to mitigate the risk that sender
      adds excessive congestion to an already congested path. The following
      mechanisms help in fulfilling this objective: <list style="symbols">
          <t>(observation phase) The sender SHOULD NOT store and/or send
          information related to a previously estimated bottleneck bandwidth
          (saved_bb) (see <xref target="sec-terms_def"></xref> for more
          details on bottleneck bandwidth definition), if the cwnd is not at
          least four times larger than the IW. <!-- this estimation has not
been computed after some rounds during the 1-RTT connection. 
At least, the 1-RTT connection should have reached the congestion avoidance phase. --></t>

          <t>(reconnaissance phase) The sender MUST NOT send more than the
          recommended maximum IW (recom_iw) in the first RTT of transmitting
          data <xref target="RFC9000"></xref>. (When used in a controlled
          network, additional information about local path characteristics
          could be known that might be used to configure a non-standard
          IW).</t>

          <t>(reconnaissance phase) The sender MUST compare the measured
          transport parameters (in particular current_rtt) of the new session
          with those of the previous session (in particular
          saved_rtt). The method MUST NOT be used when the path fails to be
          validated;</t>

          <t>(unvalidated phase) The sender MUST NOT use the parameters unless
          the first IW packets when packets are detected as lost or
          acknowledgments indicate the packets were ECN CE-marked. These are
          indication of potential congestion and therefore the method MUST NOT
          be used; </t>

          <t>(unvalidated phase) The sender MUST implement the retreat method
          when packets are detected as lost or acknowledgments indicate the
          packets were ECN CE-marked. These are indication of potential
          congestion and therefore the method MUST NOT be used.</t>

        </list></t>

      <t>The sender is limited by any rate-limitation of the transport
      protocol with which the method is used.
      For QUIC this includes: flow control mechanisms or amplification
      attack prevention. In particular, a QUIC receiver may need to issue proactive
      MAX_DATA frames to increase the flow control limits of a connection
	that is started with this method.
	<!---The maximum number of packets that can be sent without
      acknowledgments needs to be chosen to avoid the creation and the
      increase of congestion for the path.-->
	</t>

<!--- I think this relates to the BDP Frame --
      <t>This extension MUST NOT provide an opportunity for the current
      connection to be a vector for an amplification attack. The QUIC address
      validation process, used to prevent amplification attacks, SHOULD be
      performed <xref target="RFC9000"></xref>.</t> -->

      <t{>XXX-Editor-note: This should be a range rather than an
      inequality (current_rtt &lt; 1.2*saved_rtt).}</t>

      <t>The following mechanisms could be implemented: <list style="symbols">
          <t>Exploit a standard IW:<list style="numbers">
              <t>The sender sends the first data using the IW - this is
              assumed a safe starting point for any path where there is no path
              information or congestion control information. This avoids
              adding excessive congestion to a path;</t>

              <t>The sender monitors reception of the IW data. If the path
              characteristics resemble those of a recent previous connection from
              to the same sender (i.e., current_rtt &lt; 1.2*saved_rtt) and
              all data was acknowledged without reported congestion), the
              method permits the sender to utilize the saved_bb as an input to
              adapt current_bb to rapidly determine a new safe rate;</t>

              <t>The sender needs to avoid sending a burst of packets as a result of a
              step-increase in the congestion window <xref
              target="RFC9000"></xref>. Pacing the packets as a function of
              the current_rtt can provide this additional safety during the
              unvalidated period.</t>
            </list></t>

          <t>Identify a relevant pacing rhythm:<list style="symbols">
              <t>The sender estimates a pacing rhythm using saved_rtt and
              saved_bb. The Inter-packet Transmission Time (ITT) is determined
              from the ratio between the current Maximum Message Size (MMS) and
              the ratio between the saved_bb and saved_rtt. A tunable safety
              margin can avoid sending more than a recommended maximum IW
              (recom_iw): <list style="symbols">
                  <t>current_iw = min(recom_iw,saved_bb)</t>

                  <t>ITT = MSS/(current_iw/saved_rtt)</t>
                </list></t>

              <t>A  successful receipt of the IW data confirms the path can be used with
		 the method specified in this document.</t>
            </list></t>

          <t>Tune slow-start mechanisms: After transport parameters are set to
          a previously estimated bottleneck bandwidth, if the slow-start
          mechanisms continue, the sender can then overshoot the bottleneck
          capacity. This can occur even when using the safety check described
          in this section. <list style="symbols">
              <t>For NewReno and CUBIC, it is recommended to exit slow-start
              and enter the congestion avoidance phase.</t>

              <t>For BBR CC, it is recommended to enter the "probe bandwidth"
              state.</t>
            </list></t>
        </list></t>

      <t>This follows the idea presented in <xref target="RFC4782"></xref>,
      <xref target="I-D.irtf-iccrg-sallantin-initial-spreading"></xref> and
      <xref target="CONEXT15"></xref>.</t>

</section> <!--- Safety Guidelines -->

<section anchor="sec-acknowledgments" title="Acknowledgments">
      <t>The authors would like to thank John Border, Gabriel Montenegro, Patrick McManus,
      Ian Swett, Igor Lubashev, Robin Marx, Roland Bless and Franklin Simo for
      their fruitful comments on earlier versions of this document.</t>
      <t>The authors would like to particularly thank Tom Jones for co-authoring 
      previous versions of this document.</t>
</section>

<section anchor="sec-IANA" title="IANA Considerations">
      <t>TBD: Text is required to register the BDP Frame and the enable_bdp
      transport parameter. Parameters are registered using the procedure
      defined in <xref target="RFC9000"></xref>.</t>
</section>

<section anchor="sec-security" title="Security Considerations">

	<t>Security considerations for QUIC are discussed in <xref
      target="sec-safety_guide"></xref></t>

	<t> This section provides security considerations for Careful Resume.</t>

    </section> <!--- Sec Considerations>
	    
<!--- BDP FRAME-->
     <section  title="Security Considerations for the BDP Frame">

	<t>Security considerations for QUIC are discussed in <xref
     	 target="sec-safety_guide"></xref>.
	The security considerations for Careful Resume provide considerations for that method.</t>

      <t>The receiver can send information related to the saved_rtt and saved_bb
      to the sender with the BDP Frame extension using either Rationale #2 -
      Solution #2 or Rationale #2 - Solution #3. However, the sender SHOULD
      NOT trust the receiver. Indeed, even if the QUIC packets containing the BDP
      Frame are encrypted, a receiver could modify the values within the
      extension and encrypt the QUIC packet. Authentication mechanisms might
      not guarantee that the values are safe. It is not an easy operation for
      a receiver to modify authenticated or encrypted data without this being
      detected by a sender. Modification could be realized by a malicious
      receiver. One way to avoid this is for a sender to also store the
      saved_rtt and saved_bb parameters.</t>
      
       <t>A "malicious receiver" could try to send malicious
       information to a sender. Information sent by a malicious receiver is not
       relevant. A receiver could request a sender to use a cwnd higher
       than appropriate, to gain an unfair share of capacity for itself
       or to induce congestion for other flows. A sender might anyway
       decide whether to fully use the new allowed rate.</t>

      <t>A malicious receiver might modify the saved_bb parameter to convince
      the sender to use a larger CWND than appropriate. Using the algorithms
      proposed in <xref target="sec-safety_guide"></xref>, the sender may
      reduce any intended harm and can check that part of the information
      provided by the receiver are valid. Using the security mechanisms provided
      in <xref target="I-D.kuhn-quic-bdpframe-extension"></xref>, the sender can 
      verify that the receiver did not change the parameters inside the frame.</t>

      <t>Storing the BDP parameters locally at the sender reduces the
      associated risks by allowing the receiver to transmit information related
      to the BDP of the path in the case of a malicious receiver trying to break
      the encryption mechanism that it had received.</t>

 	 </section> <!--- Sec Considerations>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
(for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")
Both are cited textually in the same manner: by using xref elements.
If you use the PI option, xml2rfc will, by default, try to find included files in the same
directory as the including file. You can also define the XML_LIBRARY environment variable
with a value containing a set of directories to search.  These can be either in the local
filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <?rfc include="reference.RFC.2119.xml"?>

      <?rfc include="reference.RFC.4782.xml"?>
      <?rfc include="reference.RFC.4941.xml"?>

      <!-- <?rfc include="reference.RFC.6349.xml"?> -->

      <?rfc include="reference.RFC.6973.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>

      <?rfc include="reference.RFC.8446.xml"?>
      <?rfc include="reference.RFC.8801.xml"?>

      <?rfc include="reference.RFC.9000.xml"?>

      <!-- <?rfc include="reference.RFC.9001.xml"?> -->

      <?rfc include="reference.RFC.9002.xml"?>
      <?rfc include="reference.RFC.9040.xml"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.I-D.irtf-iccrg-sallantin-initial-spreading.xml"?>
	    
      <?rfc include="reference.I-D.cardwell-iccrg-bbr-congestion-control.xml"?>
      <?rfc include="reference.I-D.kuhn-quic-bdpframe-extension.xml"?>
	    
      <?rfc include="reference.RFC.5783.xml"?>
      <?rfc include="reference.RFC.7661.xml"?>
      <?rfc include="reference.RFC.8867.xml"?>
      <?rfc include="reference.RFC.9040.xml"?>

      
      <reference anchor="MAPRG111">
        <front>
          <title>Feedback from using QUIC's 0-RTT-BDP extension over SATCOM
          public access</title>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Stephan"></author>

          <author initials="G" surname="Fairhurst"></author>

          <author initials="T" surname="Jones"></author>

          <author initials="C" surname="Huitema"></author>

          <date year="2022" />
        </front>

        <seriesInfo name="IETF 111 - MAPRG meeting" value="" />
      </reference>

      <reference anchor="IJSCN">
        <front>
          <title>Google QUIC performance over a public SATCOM access</title>

          <author initials="L" surname="Thomas"></author>

          <author initials="E" surname="Dubois"></author>

          <author initials="N" surname="Kuhn"></author>

          <author initials="E" surname="Lochin"></author>

          <date year="2019" />
        </front>

        <seriesInfo name="International Journal of Satellite Communications and Networking"
                    value="10.1002/sat.1301" />
      </reference>

      <reference anchor="CONEXT15">
        <front>
          <title>Halfback: Running Short Flows Quickly and Safely</title>

          <author initials="Q" surname="Li"></author>

          <author initials="M" surname="Dong"></author>

          <author initials="P B" surname="Godfrey"></author>

          <date year="2015" />
        </front>

        <seriesInfo name="ACM CoNEXT" value="" />
      </reference>
    </references>

    <section anchor="endpoint_token" title="An Endpoint Token">

    <t>
    This proposes an Endpoint Token to allow a sender to identify its own
    view of the network path it is using This can be shared and used as an
    opaque path identifier to other parties and the sender can verify if
    this is one of its current paths.
    </t>

    <section title="The Problem of identifying the Path">

    <t>
    In a simple network scenario, the sending endpoint could use the IP
    source address to identify a path. This could work when one
    globally-allocated IP address is set per interface. There are many cases
    where the IP address would not an acceptable to identify a path. Section
    8 of <xref target="RFC9040"></xref> describes cases where the IP address is not a suitable
    value when performing TCP control block sharing. In general the IP
    address of the sender is made public in the network-layer header of IP
    packets. When sharing internal state, <xref target="RFC6973"></xref> identifies relevant
    privacy considerations.
    </t>

    <t>
    Examples of network uses where a source address is not a suitable endpoint
    token include:
    <list style="symbols">
	    <t>
            The sending endpoint might not be identifiable remotely from its
            IP address because a device on the network path translates the
            address using a form of NAT/NAPT. In this case, a private IP
            address might be used, which does not identify a specific
	    endpoint.
	    </t>
	    <t>
            In some cases, a sender can choose to vary the source address
            over time to avoid likability in the observable IP header, e.g.,
            because the used source address embeds private information, such as
            the endpoint's MAC address/EID.
            </t>
    </list> </t>
    <t>
    Note: There are use-cases where for the purpose of identifying a path,
    the token does not need to be globally unique, but needs to be
    sufficiently unique to prevent attempts to misrepresent the path being
    used such as an attack on the congestion controller. Using a smaller
    size of token can add to the ambiguity set, reducing this likability.
    </t>
    </section>

    <section title="Creating an Endpoint Token">
    <t>
    When computing the Endpoint Token, the sender includes information to identify
    the path on which it sends, for example:
    <list style="symbols">
	    <t>
            it must include a unique identifier for itself (e.g., a globally
            assigned address/prefix; or randomly chosen value).
	    </t>
	    <t>
            it must include an identifier for the destination (e.g., a
            destination IP address or name).
	    </t>
	    <t>
            it should an interface identifier (e.g., an index value or a MAC address to associate the
            endpoint with the interface on which the path starts);
	    </t>
	    <t>
            it could include other information such as the DSCP, ports, flow
            label, etc (recognising that this additional infromation might improve the path
            differentiation, but that this can can reduce the re-usability of the
            token);
	    </t>
	    <t>
            it could include any other information the sender chooses to
	    include, and potentially including PvD information <xref target="RFC8801"></xref> or
            information relating to its public-facing IP address;
	    </t>
	    <t>
            it could include a nonce;
	    </t>
	    <t>
            it could include a time-dependent value to define the validity
            period of the token.
	    </t>
    </list></t> 

    <t>
    NOTE: The Endpoint Token is used independently by receivers and senders. A
    receiver might decide not to provide an Endpoint Token to a sender, to
    avoid exposing additional linkable information (but also preventing use
    of any mechanism that relies on the token).
    </t>

    <t>
    When creating an Endpoint Token, the sender has to ensure the following:
    <list style="numbers">
	    <t>
            To reduce the likelihood of misuse of the Endpoint Token, the value
            should be encoded in a way that hides the component information
	    from the recipient and any eavesdropper on the path.
            </t>
	    <t>
            The sender can recalculate the Endpoint Token if it needs to validate a
            previously issued token; and that the Endpoint Token itself can be
            included in the computed integrity check for any path
            information it provides.
	    </t>
	    <t>
            The Endpoint Token is design to prevent another party from deriving
            private data from the token, or to use the token to perform
            unwanted likability with other information. This implies that
            the Endpoint Token MUST necessarily be different when used to identify
            different interfaces.
            </t>
    </list> </t>

    </section>

<!--- This is BDP frame -->
    <section title="Example use of an Endpoint Token">
    <t>
    The sender computes an Endpoint Token that seeks to uniquely identify
    the path that it uses to communicate with the receiver (1) this is
    associated with the path information it sends. The Endpoint Token ought
    to be encrypted to avoid sending linkable information observable
    eavesdroppers on the path. The receiver stores the path information
    together with the Endpoint Token, together with the sender's
    address/name (2). When the receiver later wishes the sender to use the
    stored path information it returns the information to the sender (3)
    together with the Endpoint Token. The sender recomputes the Endpoint
    Token and compares this with the received Endpoint Token before using
    the path information. The Endpoint Token ought to be encrypted while in
    transit on the path to avoid provideing an eavesdropper on the path 
	  with linkable information.
    </t>

    <list style="numbers">
	    <t>The Sender transmits the Endpoint Token to the Receiver
	    </t>
	    <t>The Receiver holds an Endpoint Token 
	    </t> 
	    <t>The Receiver transmits the Endpoint Token to the Sender 
	    </t>
    </list>
    </section> <!-- 

    <section title="A Change of the Source Address">
    <t>
    When the source address changes (e.g. it is derived from randomised
    information, and changes from use to use <xref target="RFC4941"></xref>). In this case the
    Endpoint Token might need to be consistent across this change, and the remote
    receiver will need to also be able identify the original sender to
    return the corresponding Endpoint Token.
    </t>
    </section>

<!--- BDP Frame
    <section title="Security Related to use of the Endpoint Token">
    <t>
    A number of security-related topics have been discussed, mostly
    concerning the potential exposure of the identity on the path. This information can
    also be visible in the IP source address or higher-layer data, but can
    be hidden from a remote endpoint using methods such as MASQUE proxy.
    When used to inform the transport system using a layered proxy, the
    transport endpoint token refers to the endpoints of the outer QUIC
    header, and hence the proxy itself, not the end-to-end communication
    relayed by the proxy.
    </t>
    <t>
    A sender might decide to not use this method if it has a stroing requirement to prevent
    flows being linkable with previous flows to the same endpoint. A
    decision not to provide an Endpoint Token necessarily prevents the
    sender from requesting the receiver to return path information to allow
    the same transport information to be re-used, potentially strengthening
    privacy but consequently eliminating any performance benefits.
    </t>
    </section>

<!--- BDP Frame --->
      <section anchor="sec:discuss_bdp_default"
               title="Trade-off between the different solutions">
        <t>This section provides a description of several implementation
        options and discusses their respective advantages and drawbacks. </t>

        <t>While there are some discussions for the solutions regarding
        Rationale #2, the sender MUST consider Rationale #1 - Solution #2 and
        avoid Rationale #1 - Solution #1: the sender MUST implement a safety
        check to measure whether the saved BDP parameters (i.e. saved_rtt and
        saved_bb) are relevant or check that their usage would not cause
        excessive congestion over the path. </t>

        <t>
        The method used to store the transport parameters
        SHOULD be associated with a lifetime. If no lifetime expiration
        is provided, safety guidelines should help guarantee that the
        session resumption is careful. While the sender may not specify
        how long the data is stored at its level (for the local storage
        solution), BDP extension Frame proposes a extension_lifetime
        parameter and "token SHOULD have an expiration time" 
        <xref target="RFC9000"></xref>.
        </t>

<!--- BDP frame --->
<section anchor="sec-implem" title="Implementation Considerations">
      <section anchor="sec-bdp_frame"
               title="Rationale behind the different implementation options">
        <t>The NewSessionTickets message of TLS can offer a solution. The
        proposal is to add a 'bdp_metada' field in the NewSessionTickets,
        which the receiver is able to read. The only extension currently defined
        in TLS1.3 that can be seen by the receiver is max_early_data_size (see
        Section 4.6.1 of <xref target="RFC8446"></xref>). However, in the
        general design of QUIC, TLS sessions are managed by a TLS stack.</t>

        <t>Three distinct approaches are presented: sending an opaque blob to
        the receiver that the receiver may return to the sender when establishing
        a future new connection (see <xref
        target="sec-using_new_token"></xref>), enabling local storage of the
        BDP information (see <xref target="sec-local_storage"></xref>) and a
        BDP Frame extension (see <xref
        target="sec-bdp_frame_section"></xref>).</t>
      </section>

      <section anchor="sec-local_storage"
               title="Independent Local Storage of Values">
        <t>This approach independently lets both a receiver and a sender store
        their BDP parameters: <list style="symbols">
            <t>During a 1-RTT session, the endpoint stores the RTT (as the
            saved_rtt) and bottleneck bandwidth (as the saved_bb) together in
            the session resume ticket. 
            </t>

            <t>The sender maintains a table of previously issued tickets,
            indexed by the random ticket identifier that is used to guarantee
            uniqueness of the Authenticated Encryption with Associated Data
            (AEAD) encryption. Old tokens are removed from the table using the
            Least Recently Used (LRU) logic. For each ticket identifier, the
            table holds the RTT and bottleneck bandwidth (i.e. saved_rtt and
            saved_bb), and also the Endpoint Token of the receiver (i.e.
            saved_endpoint_token).</t>
          </list></t>

        <t>During the new session establishment (0-RTT or 1-RTT), the local endpoint waits for the first
        RTT measurement from the remote peer. This is used to
        verify that the current_rtt has not significantly changed from the
        saved_rtt (used as an indication that the BDP information is
        appropriate for the current path).</t>

        <t>If this RTT is confirmed, the endpoint also verifies that an IW of
        data has been acknowledged without requiring retransmission or
        resulting in an ECN CE-mark. This second check detects whether a path
        is experiencing significant congestion (i.e., where it would not be
        safe to update the cwnd based on the saved_bb). In practice, this
        could be realized by a proportional increase in the cwnd, where the
        increase is (saved_bb/IW)*proportion_of_IW_currently-ACKed.</t>

        <t>This solution does not allow a receiver to request the sender not to
        use the BDP parameters. If the sender does not want to store the
        metrics from previous connections, an equivalent of the
        tcp_no_metrics_save for QUIC may be necessary. This option could be
        negotiated that allows a receiver to choose whether to use the saved
        information.</t>
      </section>

      <section anchor="sec-using_new_token" title="Using NEW_TOKEN frames">
        <t>A sender can send a NEW_TOKEN Frame to the receiver. The token is an
        opaque (encrypted) blob and the receiver can not read its content (see
        section 19.7 of <xref target="RFC9000"></xref>). The receiver sends the
        received token in the header of an Initial packet of a later
        connection.</t>
      </section>

      <section anchor="sec-bdp_frame_section" title="BDP Frame">
        <t>Using BDP Frames, the sender could send information relating to the
        path characteristics to the receiver. The use of the BDP Frame is
        negotiated with the receiver. The receiver can read its content. If the
        receiver agrees with the usage of previous parameters, it can
        send the BDP Frame back to the sender in an Initial packet of a later
        connection.</t>
      </section>
	
	<section title="Summary">
        <!--- BDP ---   <t> Local storage of values can be secure and the BDP Frame
          extension provides more information to the receiver and more
          interoperability. The <xref target="fig-summary"></xref> provides a
          summary of the advantages and drawbacks of each approach.</t> --->

          <figure anchor="fig-summary" title="Comparing Careful Resume solutions">
            <artwork><![CDATA[
+---------+-----------+----------------+---------------+-----------+
|Rationale| Solution  |    Advantage   |    Drawback   |  Comment  |
+---------+-----------+----------------+---------------+-----------+
|#1       |#1         |                |               |           |
|Variable |set        |Ingress optim.  |Risk of adding |MUST NOT   |
|Network  |current_*  |                | congestion    |implement  |
|         |to saved_* |                |               |           |
|         +-----------+----------------+---------------+-----------+
|         |#2         |                |               |           |
|         |Implement  |Reduce risk of  |Negative impact|MUST       |
|         |safety     | adding         | on ingress    |implement  |
|         |check      | congestion     | optim.        |Section 3  |
+---------+-----------+----------------+---------------+-----------+


]]></artwork>
          </figure>
		
<!--- BDP frame -->

<figure anchor="fig-summary" title="Comparing BDP-Frame Solutions">
            <artwork><![CDATA[
+---------+-----------+----------------+---------------+-----------+
|Rationale| Solution  |    Advantage   |    Drawback   |  Comment  |
+---------+-----------+----------------+---------------+-----------+
|#2       |#1         |                |               |           |
|Malicious|Local      |Enforced        |A receiver is  |           |
|receiver |storage    | security       | unable        |           |
|         |           |                | to reject     |           |
|         |           |                |Malicious      |           |
|         |           |                | sender could  |           |
|         |           |                | fill a        |           |
|         |           |                | receive buffer|           |
|         |           |                |Limited        |           |
|         |           |                | use-cases     |Section 4.2|
|         +-----------+----------------+---------------+-----------+
|         |#2         |                |               |           |
|         |NEW_TOKEN  |Save resource   |A malicious    |           |
|         |           | at sender      | receiver could|           |
|         |           |Opaque token    | change token  |           |
|         |           | protected      | even if       |           |
|         |           |                | protected     |           |
|         |           |                |A malicious    |           |
|         |           |                | sender could  |           |
|         |           |                | fill the      |           |
|         |           |                | receive buffer|           |
|         |           |                |sender may not |           |
|         |           |                | trust receiver|Section 4.3|
|         +-----------+----------------+---------------+-----------+
|         |#3         |                |               |           |
|         |BDP        |Extended        |A malicious    |           |
|         |extension  | use-cases      | receiver could|           |
|         |           |Save resource   | change BDP    |           |
|         |           | at sender      | even if       |           |
|         |           |A receiver can  | protected     |           |
|         |           | read and decide|A sender may   |           |
|         |           | to reject      | not trust a   |           |
|         |           |BDP extension   | receiver      |           |
|         |           | protected      |               |           |
|         |           |                |               |Section 4.4|
+---------+-----------+----------------+---------------+-----------+

{XXX-Editor-Note: Need to clarify the text around changing 
the authenticated token.}

]]></artwork>
          </figure>
		
		
        </section> <!-- End of Safety: Summary --->
    </section>
  </back>
</rfc>
<!-- </t> Four cases are identified:
<list style="numbers">
<t> The network path has changed and the new path is
different. This might be evident from a change of local interface, a change
in the client or sender IP address, or similar indication from the network.
Using the saved congestion control information could increase congestion.</t>
<t> The network path has changed, but the new path is not known to be
different. This case might be accompanied by a change in the RTT, or
evident by loss observed at the start of the new connection and
the saved congestion control information is not appropriate. </t>
<t> The network conditions have changed and it is discovered that
the current capacity is
less than the previously estimated bottleneck bandwidth. Using the saved
congestion control information would then increase congestion, and the flow needs
to adjust to a lower safe rate; </t>
<t> The stored information is too old. In this case, it is no longer
be reasonable to expect the path to have same characteristics, and the
the saved congestion control information is no longer appropriate.</t>
</list></t>

<t>In all these case, the
careful increase method is not be used, and a sender needs to return to
a standard behavior.  The method can still be used to characterize the new path,
enabling later flows to use this method.</t>

-->
